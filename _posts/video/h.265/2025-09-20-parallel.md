---
layout: post
title: H.265并行加速
slug: h265-parallel
categories: [视频开发]
tags: [H.265]
date: 2025-09-20 12:00:00 +0800
---

好的，我们来深入详解HEVC中一项非常关键且精妙的并行处理技术——**波前并行处理（Wavefront Parallel Processing, WPP）**。

这是HEVC为解决熵编码的串行瓶颈而设计的核心工具之一，也是它能够高效处理4K/8K超高清视频的关键。



### 1. WPP的核心目标：打破CABAC的串行依赖



要理解WPP，首先要明白它要解决的问题。

在传统的熵编码（如H.264的CABAC）中，存在一个严格的**串行数据依赖**：

+   编码第 `N` 个语法元素时，所使用的概率模型（上下文）依赖于第 `N-1` 个元素编码结束后的概率状态。
+   编码第 `K` 个编码块（CU/CTU）时，CABAC引擎的初始状态依赖于第 `K-1` 个块编码完成后的最终状态。

这就形成了一条长长的、无法断开的依赖链，贯穿整个切片（Slice）。在单核处理器时代，这不是问题。但在多核处理器时代，这意味着熵编码这个环节**无法被有效并行**，一个拥有64核的强大CPU在处理一个Slice的熵编码时，也只有一个核心在工作，极大地限制了编码器的吞吐量。

**WPP的核心目标，就是打破这条贯穿整行的串行依赖链，使得同一行（Row）的多个CTU可以被并行处理。**



### 2. WPP的工作原理



WPP通过重构依赖关系，将“水平”的强依赖变为了“垂直”的弱依赖，从而“解锁”了行内的并行能力。



#### 2.1 打破行内依赖（Breaking Intra-Row Dependencies）



这是WPP最核心的技巧。对于一个CTU行（Row of CTUs）中的所有CTU，WPP规定：

+   **除了每行的第一个CTU外，该行所有后续CTU在开始进行熵编码时，都使用相同的CABAC初始状态。**
+   这个初始状态是什么呢？就是**上一行CTU全部编码结束后的CABAC最终状态**。

这意味着，`CTU_i,j`（第`i`行，第`j`列）的熵编码**不再依赖于**`CTU_i,j-1`（它左边的邻居）。因此，`CTU_i,1`, `CTU_i,2`, `CTU_i,3`... 就可以在多个CPU核心上**同时开始**它们的熵编码过程。



#### 2.2 建立行间依赖（Establishing Inter-Row Dependencies）



虽然行内依赖被打破了，但为了尽可能保持编码效率（上下文的准确性），WPP保留了行与行之间的依赖。

+   第 `i` 行的熵编码处理，需要等待第 `i-1` 行处理到一定程度后才能开始。
+   具体来说，处理 `CTU_i,0`（第`i`行第1个CTU）时，为了获取正确的空间上下文（例如，来自其右上方邻居的信息），它必须等待 `CTU_i-1,1`（上一行第2个CTU）的**解码/编码决策**完成。



#### 2.3 “波前”的形成 (The Formation of the "Wavefront")



将上述两个规则结合起来，就形成了一个“波浪”式向前推进的处理阵线，这就是“波前”这个名字的由来。

**ASCII图表：WPP处理流程** (`C_ij` 表示第`i`行第`j`列的CTU, `Core k` 表示第`k`个CPU核心)

```
Time --->
      T=1        T=2        T=3        T=4        T=5
      +----------+----------+----------+----------+----------+
Core 0| C_00     | C_01     | C_02     | C_03     | C_04     | ... (Row 0: 串行处理)
      +----------+----------+----------+----------+----------+
Core 1|          | C_10     | C_11     | C_12     | C_13     | ... (Row 1: 延迟开始, 之后并行)
      +----------+----------+----------+----------+----------+
Core 2|          |          | C_20     | C_21     | C_22     | ... (Row 2: 进一步延迟, 之后并行)
      +----------+----------+----------+----------+----------+
Core 3|          |          |          | C_30     | C_31     | ... (Row 3: ...)
      +----------+----------+----------+----------+----------+
...   |          |          |          |          |          |
```

**流程解读**:

1.  **时刻T=1**: 只有Core 0在工作，处理第一行第一个CTU `C_00`。
1.  **时刻T=2**: Core 0处理 `C_01`。此时，`C_10` 所需的上下文依赖已经满足，Core 1可以**开始**处理 `C_10`。
1.  **时刻T=3**: Core 0处理 `C_02`。Core 1处理 `C_11`。Core 2可以**开始**处理 `C_20`。
1.  **从T=3开始**: 我们看到，多个核心（Core 0, 1, 2...）都在**同时**处理不同行的CTU。这个沿对角线方向（从左上到右下）推进的处理边界，就是“波前”。



### 3. WPP的比特流结构



为了让解码器也能利用WPP进行并行解码，编码器会在比特流中写入特殊的信令。

+   当一个切片（Slice）启用了WPP，它的数据部分会被分割成多个**子流（substreams）**，每个子流对应一行CTU的数据。
+   在切片头部（Slice Header）中，会包含一个**入口点偏移列表（Entry Point Offsets）**。这个列表指明了每个CTU行的比特流在整个切片数据中的起始位置。
+   这样，多线程解码器在解析完头部后，每个线程就可以根据入口点偏移，直接跳转到自己负责的CTU行的起始位置开始解码（同样要遵循波前依赖规则）。



### 4. WPP vs. Tiles：性能与效率的权衡



WPP是HEVC中与Tiles并列的另一大并行技术，但它们的取舍不同。

| 特性             | WPP (波前并行处理)                         | Tiles (瓦块)                                             |
| ---------------- | ------------------------------------------ | -------------------------------------------------------- |
| **依赖关系**     | 行与行之间存在上下文依赖                   | Tile之间**完全独立**，无任何依赖                         |
| **并行粒度**     | CTU行                                      | Tile（可配置的矩形区域）                                 |
| **压缩效率损失** | **极小** (通常 < 1%)，因保留了大部分上下文 | **无**（Tile内部），但Tile边界可能因预测中断导致效率下降 |
| **比特流结构**   | 单个切片，包含入口点偏移                   | 每个Tile的数据是独立的，可以封装在独立的NAL单元中        |
| **适用场景**     | 需要高并行度且对压缩效率极其敏感的场景     | 需要极高并行度、容错或对视频进行区域化处理的场景         |

导出到 Google 表格

**核心权衡**:

+   WPP为了保留大部分的上下文依赖，牺牲了一点点并行自由度（需要等待上一行），换来了**几乎无损的压缩效率**。
+   Tiles为了实现最彻底的并行（完全独立），牺牲了跨越边界的上下文信息，可能会带来一些编码效率损失。



### 总结



WPP是一项极其优雅的工程设计。它并非粗暴地切断所有依赖，而是在“保留上下文以维持高压缩率”和“打破依赖以实现高并行度”之间找到了一个绝佳的平衡点。

+   **它实现了大规模并行**: 允许数十甚至上百个核心协同工作。
+   **它维持了高编码效率**: 相比完全关闭并行，码率损失通常可以忽略不计。
+   **它是HEVC能够应对超高清视频实时处理挑战的基石技术**。

理解了WPP，就理解了现代视频编解码器是如何在算法理论和硬件现实之间进行巧妙权衡的。