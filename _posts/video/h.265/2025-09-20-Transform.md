---
layout: post
title: H.265 变换
slug: h265-transform
categories: [视频开发]
tags: [H.265]
date: 2025-09-20 07:00:00 +0800
---

变换将空间域的残差信号转换为频域系数。

在进行帧内（Intra）或帧间（Inter）预测后，我们会得到一个**残差块（Residual Block）**。这个块虽然数据范围比原始图像小，但仍然存在大量的空间相关性。

变换（Transform）的目的有两个：

1.  **去相关（Decorrelation）**: 打破像素之间的空间依赖性，使得每个值都尽可能独立。
1.  **能量集中（Energy Compaction）**: 将信号的大部分能量集中到少数几个低频系数上。

变换之后，我们会得到一个**系数块（Coefficient Block）**。这个块的特点是，大部分能量（即较大的数值）都集中在左上角（低频区域），而右下角（高频区域）则充满了大量接近于零的值。这样一来，后续的量化（Quantization）步骤就可以大胆地将这些高频的小系数直接置为0，从而实现高效压缩。



### 2. HEVC变换的核心特点

#### 2.1 多样化的变换块尺寸 (Variety of Transform Block Sizes)

HEVC支持的变换尺寸与编码单元（CU）的尺寸紧密相关，支持从4x4到32x32的方形变换：

+   **4x4**
+   **8x8**
+   **16x16**
+   **32x32**

**为什么需要大尺寸变换？** HEVC引入了更大的预测单元（PU最大可达64x64）。对于大尺寸PU产生的平坦区域的残差，使用相应的大尺寸变换（如32x32）可以更好地捕获整个区域的能量分布，其能量集中效果远优于将大块切分成多个小块（如H.264只能用4x4或8x8）分别进行变换。

变换完成后，系数会按照特定的**扫描顺序（Scanning Order）**进行一维化，以便于后续的熵编码。通常是从左上角的直流（DC）系数开始，沿反对角线方向进行“Z”字形扫描。

**ASCII图表：典型的系数扫描路径**

代码段

```
      Frequency U -->
 F   +-----> coefficients sent to entropy coder
 r + | DC | 01 | 05 | 06 | ...
 e | | 02 | 04 | 07 |
 q V | 03 | 08 |
   v | 09 | ...
     | ...
```

#### 2.2 离散余弦变换 (DCT-II) 与 离散正弦变换 (DST-VII)

HEVC不仅仅使用了传统的DCT，还针对特定场景引入了DST。

+   **DCT-II (Discrete Cosine Transform, Type II)**: 这是标准的主力变换，基于偶对称的余弦函数。它适用于绝大多数情况，包括**所有的色度（Chroma）块**和**大部分亮度（Luma）块**。DCT的第一个基函数是一个平坦的直流分量，非常适合对那些整体比较平滑的残差块进行能量压缩。

+   **DST-VII (Discrete Sine Transform, Type VII)**: 这是HEVC的一大创新，基于奇对称的正弦函数。DST被**专门**用于 **4x4 亮度的帧内预测（Intra-predicted）块**。

    **为什么在这里要用DST？** 在帧内预测中，预测块是根据相邻的已编码像素生成的。这会导致残差块的边界处（靠近用于预测的像素）的值通常接近于0，而离边界越远，残差值可能越大。

    +   DCT的基函数假设信号在边界是平坦的（偶对称），这与Intra残差的特性不符。
    +   DST的基函数在块的边界处值为0（奇对称），这恰好能非常高效地拟合Intra残差的信号分布。 因此，对于4x4的Luma Intra残差，使用DST能实现比DCT更好的能量集中效果，从而节省比特。

#### 2.3 基于整数的变换 (Integer-based Transform)

和H.264一样，HEVC使用的DCT/DST都是**整数近似**。标准中定义了变换矩阵，所有计算都通过整数的加法、乘法和移位来完成。这样做的好处是：

+   **避免失配（Mismatch）**: 保证编码器和解码器之间的计算结果完全一致，避免了浮点运算带来的精度误差累积问题。
+   **计算效率**: 整数运算通常比浮点运算更快，更易于硬件实现。

### 3. 变换单元 (Transform Unit, TU)

这是理解HEVC变换机制的**关键概念**。HEVC将CU、PU、TU的概念分离开来。

+   **CU (Coding Unit)**: 编码决策的基本单元，决定了块的划分。
+   **PU (Prediction Unit)**: 预测的基本单元，决定了Intra/Inter预测的方式和分区。
+   **TU (Transform Unit)**: 变换和量化的基本单元。

一个CU可以包含一个或多个TU。这种分离提供了巨大的灵活性，其结构由**残差四叉树（Residual Quad-Tree, RQT）**决定。

**例子**: 一个32x32的CU，根据其残差的复杂性，编码器（通过RDO）可以决定：

1.  **不分割TU**: 整个32x32的残差块直接进行一次32x32的变换。这适用于残差非常平坦简单的场景。
1.  **分割一次TU**: 将32x32的残差块分割成4个16x16的TU，每个TU再独立进行16x16的变换。
1.  **递归分割TU**: 某个16x16的TU还可以继续分割成4个8x8的TU。

**ASCII图表：TU在CU内的划分**

代码段

```
+-----------------------------------+
|      32x32 Coding Unit (CU)       |
|                                   |
| +-----------------+---------------+
| |                 |   16x16 TU    |
| |   16x16 TU      +---------------+
| |                 |   16x16 TU    |
| +-----------------+-+-----+-------+
| |    16x16 TU     | | 8x8 | 8x8 |
| |                 | +-----+-----+
| |                 | | 8x8 | 8x8 |
| +-----------------+-+-----+-------+
```

这个决策过程由编码器的**率失真优化（RDO）**驱动。编码器会计算不同TU划分方式下的R-D Cost，选择代价最低的方案。例如，如果一个大块残差的某个角落很复杂，而其他地方很平滑，RQT允许编码器只在那个复杂的角落使用更小的TU，而在平滑区域使用大的TU，实现了效率和精度的完美平衡。

### 4. 数学公式

虽然HEVC内部使用整数矩阵运算，但其理论基础仍然是标准的DCT/DST。

+   **1D DCT-II (N点)**:

$$ Y[k] = \sqrt{\frac{2}{N}} \sum_{n=0}^{N-1} x[n] \cos\left(\frac{\pi(2n+1)k}{2N}\right) $$

+   **1D DST-VII (N点)**:

$$ Y[k] = \sqrt{\frac{2}{N}} \sum_{n=0}^{N-1} x[n] \sin\left(\frac{\pi(n+1)(k+1)}{N+1}\right) $$
