---
layout: post
title: H.265量化
slug: h265-quant
categories: [视频开发]
tags: [H.265]
date: 2025-09-20 08:00:00 +0800
---

变换将残差块的能量集中到了少数低频系数上，但这些系数仍然是精度较高的数值，需要大量比特来表示。量化的核心作用有两个：

1.  **信息减少 (Information Reduction)**: 这是压缩过程中**最主要的信息损失源**。它通过降低变换系数的精度来大幅减少需要编码的数据量。这是一个不可逆的过程，丢失的精度在解码端无法恢复。
1.  **创造零值 (Creating Zeros)**: 量化过程会将大量（特别是高频区域的）小系数直接映射为零。一个充满了零的系数块非常利于后续的熵编码（如游程编码, Run-Length Encoding），能够极大地提升压缩率。

简单来说，**量化就是用一个参数（量化步长）去除以变换系数，然后取整**。这个“除法”操作就是信息减少的核心。



### QP 与 量化步长

在HEVC中，我们不直接控制量化步长，而是通过控制**量化参数（Quantization Parameter, QP）**来实现。

+   **QP**: 一个范围从0到51的整数。**QP越小，量化程度越轻，图像质量越高，但码率也越高**。反之，QP越大，量化越粗暴，图像质量越差，但码率越低。
+   **量化步长 (Quantization Step, Qstep)**: 这是实际用于量化计算的除数。

QP和Qstep之间是一种**指数关系**：**QP每增加6，Qstep就近似翻倍**。这种对数映射关系更符合人类视觉系统对失真的感知。

这个关系可以用以下公式表示：$ Qstep(QP) = 2^{(QP - 4) / 6} $

**举例**:

+   当 `QP = 22` 时, Qstep=2(22−4)/6=23=8
+   当 `QP = 28` 时, Qstep=2(28−4)/6=24=16 (QP增加6，Qstep翻倍)

HEVC标准中预定义了一个包含52个值的`Qstep`查找表，实际计算时直接查表即可。

### 标量量化

对于一个给定的变换系数 `C`，其前向量化（编码器端）和反量化（解码器和编码器内部重构环路）过程如下：

#### 前向量化

$$ level = \text{sign}(C) \times \left\lfloor \frac{|C|}{Qstep} + f \right\rfloor $$

+   `level`: 量化后的系数级别（一个整数）。
+   `C`: 原始变换系数。
+   `Qstep`: 根据QP计算出的量化步长。
+   `f`: 一个舍入偏移量（rounding offset），通常在 0 到 0.5 之间。在标准量化中可能是固定的（如0.5，即四舍五入），但在RDOQ中会动态调整。

这个过程本质上就是将系数 `C` 映射到 `Qstep` 的整数倍上。所有落在 `[-Qstep, +Qstep]` 这个“盲区”（Dead-zone）内的系数都会被量化为0。

#### 反量化

$$ C' = \text{sign}(level) \times level \times Qstep $$

+   `C'`: 重建后的变换系数。

解码器接收到量化级别 `level` 后，执行反量化操作得到 `C'`。很明显，`C'` 只是 `Qstep` 的一个整数倍，它与原始系数 `C` 之间存在**量化误差 `(C - C')`**，这就是信息损失的来源。

### HEVC量化的关键特性

#### 基于块的QP调整

QP并非在整个图像中都是固定的。HEVC允许在**编码单元（CU）**级别对QP进行微调。

+   一个初始QP在**切片（Slice）**级别设定。
+   对于每个CU，编码器可以传输一个**`cu_qp_delta`**值，即相对于前一个CU的QP的差值。
+   这使得编码器可以为不同的区域分配不同的QP。例如，对于人眼敏感的区域（如人脸），可以使用较小的QP（`cu_qp_delta`为负数）来保留更多细节；对于纹理复杂或不重要的背景区域，可以使用较大的QP来节省码率。这就是**自适应量化（Adaptive Quantization, AQ）**的基础。

#### 量化矩阵

人眼对不同频率的噪声敏感度是不同的。我们对低频区域（平滑区域）的失真很敏感，但对高频区域（边缘、细节）的失真容忍度较高。

HEVC利用这一点，引入了**量化矩阵**（也叫 `Scaling Lists`）。这是一个与变换块同样大小的矩阵，其中每个元素都是一个**缩放因子**。在量化前，变换系数会先与这个矩阵中对应位置的因子相乘（或等效地，调整`Qstep`）。

**ASCII图表：一个典型的8x8量化矩阵示意**

```
+-------------------------------------------------+
| Low Freq (more important) | High Freq (less important) |
| Smaller scaling factors   | Larger scaling factors     |
+-------------------------------------------------+
| 8,  9, 10, 11, 12, 13, 14, 15 | <-- Quantize gently
| 9, 10, 11, 12, 13, 14, 15, 16 |
| 10, 11, 12, 13, 14, 15, 16, 17 |
| ...                           |
| 15, 16, 17, 18, 19, 20, 21, 22 | <-- Quantize aggressively
+-------------------------------------------------+
```

+   **作用**: 对低频系数使用较小的缩放因子（量化更精细），对高频系数使用较大的缩放因子（量化更粗糙）。
+   **信令**: 编码器可以在SPS（序列参数集）或PPS（图像参数集）中发送自定义的量化矩阵，解码器据此进行反量化。如果未发送，则使用默认的平坦矩阵（所有因子相同）。

#### 率失真优化量化 (RDOQ)

传统的量化（如公式所示）只是一个固定的数学运算。但RDOQ将其提升为一个**决策过程**。

对于每一个待量化的系数 `C`，它不只是简单地计算 `round(C/Qstep)`，而是会考虑量化到相邻的两个级别（比如 `L` 和 `L+1`）分别带来的**率失真代价（R-D Cost）**。

Cost=D+λ⋅R

+   **D (Distortion)**: 量化到该级别后引入的失真，即 `(C - C')^2`。
+   **R (Rate)**: 编码该量化级别 `level` 所需的比特数。
+   `λ`: 平衡码率和失真的拉格朗日乘子。

编码器会选择使 `Cost` 最小的那个 `level`作为最终的量化结果。RDOQ能够在码率几乎不变的情况下，通过更“聪明”的舍入决策，显著提升重建图像的质量（通常能带来0.5dB甚至更高的PSNR提升）。虽然计算复杂度很高，但效果显著。

#### 变换跳过模式下的量化 

当一个块使用**变换跳过（Transform Skip）**模式时，变换步骤被省略，量化直接作用于空间域的残差信号。这个过程与常规量化类似，但由于输入数据的统计特性完全不同（不再是频域系数），其内部的缩放和处理会有所差异。
