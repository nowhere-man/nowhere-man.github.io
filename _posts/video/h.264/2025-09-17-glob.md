---
layout: post
title: H.264 指数哥伦布编码
slug: h264-glob
categories: [视频开发]
tags: [H.264]
date: 2025-09-17 06:10:00 +0800
---


指数哥伦布编码（Exponential-Golomb Coding，简称 Exp-Golomb）**在 H.264 中的具体应用。

指数哥伦布编码是一种无损熵编码方法，属于可变长度编码（VLC）的一种。它的核心设计思想是：**为值越小、出现概率越高的非负整数分配越短的码字**。这与视频编码中很多语法元素（如运动向量差、残差系数等）的统计分布特性完美契合——它们通常都集中在零附近。

在 H.264 中，指数哥伦布编码是**非 CABAC (非算术编码) 模式下的主要熵编码工具**。当熵编码模式设置为 CAVLC 时（或者对于那些不使用 CAVLC/CABAC 编码的语法元素），指数哥伦布编码就承担了对绝大多数语法元素的编码任务。

它主要分为以下几种类型，并应用在不同的方面：



### 1. `ue(v)`: 无符号指数哥伦布编码 (Unsigned Exp-Golomb)



这是最基础的类型，用于编码**非负整数**。它的编码规则比较独特，通过前缀 `0` 的数量来指示码字的长度。

**编码原理简述：**

1. 将数值 `v` 加 1，得到 `v+1`。
1. 将 `v+1` 写成二进制形式。
1. 计算其二进制的位数 `L`。
1. 最终码字由 `L-1` 个前导 `0` 和 `v+1` 的二进制形式拼接而成。

**示例:**

+ `v = 0` -> `v+1 = 1` -> 二进制 `1` -> `L=1` -> 码字: `1`
+ `v = 1` -> `v+1 = 2` -> 二进制 `10` -> `L=2` -> 码字: `010`
+ `v = 2` -> `v+1 = 3` -> 二进制 `11` -> `L=2` -> 码字: `011`
+ `v = 8` -> `v+1 = 9` -> 二进制 `1001` -> `L=4` -> 码字: `0001001`

**在 H.264 中的主要应用：**

+ **`mb_type` (宏块类型)**：在 I 帧、P 帧、B 帧中，宏块的类型（如 I_4x4, I_16x16, P_SKIP, B_8x8 等）是用 `ue(v)` 编码的。因为小的、简单的宏块类型（如 Skip）出现概率最高。
+ **`cbp` (Coded Block Pattern)**：这是一个比特掩码，用来指示一个宏块中哪些 8x8 或 4x4 子块包含了非零的残差系数。这个值也用 `ue(v)` 编码。
+ **`ref_idx_l0` / `ref_idx_l1` (参考帧索引)**：当一个宏块有多个参考帧可选时，其选择的参考帧索引号。索引号为 0 的参考帧（通常是最近的前一帧）被使用的概率最高。
+ **`delta_qp` (量化参数差值)**：宏块级的 QP 通常是在 Slice 级的 QP 基础上进行微调，这个差值 `delta_qp` 通常很小或为 0，非常适合用 `se(v)`（见下文，`se(v)` 基于 `ue(v)`）来编码。



### 2. `se(v)`: 有符号指数哥伦布编码 (Signed Exp-Golomb)



这种类型用于编码**有符号整数**（正数、负数和零）。它非常巧妙地将有符号数映射到无符号数，然后直接调用 `ue(v)` 来编码。

**映射规则：**

+ 如果 `v > 0`，映射为 `2v - 1`。
+ 如果 `v <= 0`，映射为 `-2v`。

**映射结果:** `v` = `0, 1, -1, 2, -2, 3, -3, ...` 映射后 -> `0, 1, 2, 3, 4, 5, 6, ...`

这样，绝对值越小的数（无论正负），映射后的无符号整数就越小，从而获得更短的码字。`0` 的码字最短。

**在 H.264 中的主要应用：**

+ **`mvd_l0` / `mvd_l1` (运动向量差)**：运动向量（MV）本身是具有空间相关性的。因此，H.264 不直接编码 MV，而是编码当前块 MV 与其邻近块 MV 的**预测值**之间的**差值 (MVD)**。这个差值绝大多数情况下都集中在 `(0,0)` 附近，因此 `se(v)` 是对其进行编码的完美选择。
+ **`delta_qp` (量化参数差值)**：如上所述，QP 的差值有正有负，用 `se(v)` 编码。



### 3. `me(v)`: 宏块类型指数哥伦布编码 (Mapped Exp-Golomb)



这是 `ue(v)` 的一种变体，专门为 I 宏块和 B 宏块的 `mb_type` 设计。它通过一个**预定义的映射表**，将 `mb_type` 的原始值（这些值可能不连续且分布不均）映射到一组连续的、概率更优的码号上，然后再对这些码号使用 `ue(v)` 编码。

这样做的好处是，可以将那些在特定 Slice 类型下出现概率更高的 `mb_type` 映射到更小的码号，从而进一步提高编码效率。



### 4. `te(v)`: 截断指数哥伦布编码 (Truncated Exp-Golomb)



这种类型用于编码取值范围有限的语法元素。当你知道一个变量 `v` 的取值范围是 `[0, x]` 时，再使用 `ue(v)` 可能会产生一些冗余。

**编码原理：**

+ 如果 `x > 1`，`te(v)` 的编码方式与 `ue(v)` 基本相同，但对于某些值，它会使用固定长度的编码来代替，以避免码字超出表示范围。
+ 如果 `x = 1`，`te(v)` 就退化成了一个 1 比特的定长编码（`0` 或 `1`）。

**在 H.264 中的主要应用：**

+ **`coeff_token` 中的一部分**：在 CAVLC 中，`coeff_token` 的编码会用到 `te(v)`。
+ **`cbp` (Coded Block Pattern)**：当宏块是帧内预测（Intra）类型时，其色度 `cbp` 的取值范围是 `[0, 2]`，此时使用 `te(v)` 进行编码。
+ **其他取值范围受限的语法元素**。



### 总结



我们可以看到，指数哥伦布编码及其变体在 H.264 的非算术编码路径中扮演着基石的角色。它就像一个多功能的工具箱，为不同统计特性和取值范围的语法元素提供了量身定制的、高效的 VLC 解决方案。

| 编码类型             | 主要特点                             | 在 H.264 中的典型应用                                        |
| -------------------- | ------------------------------------ | ------------------------------------------------------------ |
| **`ue(v)`** (无符号) | 编码非负整数，值越小码字越短。       | `mb_type`, `ref_idx`, 宏块预测模式 (`intra_chroma_pred_mode`) |
| **`se(v)`** (有符号) | 编码有符号整数，绝对值越小码字越短。 | **`mvd` (运动向量差)**, **`delta_qp` (QP 差值)**             |
| **`me(v)`** (映射)   | 通过查表映射后再用 `ue(v)`。         | I 宏块和 B 宏块的 `mb_type`                                  |
| **`te(v)`** (截断)   | 适用于取值范围有限的变量。           | 色度 `cbp`, CAVLC 中的部分元素                               |