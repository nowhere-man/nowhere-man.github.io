---
layout: post
title: H.264 熵编码
slug: h264-entropy
categories: [视频开发]
tags: [H.264]
---

在经过预测、变换和量化之后，我们得到了一系列的量化后的变换系数和一些边信息（如宏块类型、运动向量等）。熵编码的任务就是以尽可能少的比特数来无损地表示这些数据。

H.264 主要提供了两种熵编码方案：

1. **CAVLC (Context-Adaptive Variable-Length Coding)**：基于上下文自适应的可变长度编码。这是 Baseline Profile 和 Main Profile 中对残差数据的默认编码方法，复杂度较低。
1. **CABAC (Context-Adaptive Binary Arithmetic Coding)**：基于上下文自适应的二进制算术编码。这是 Main Profile 和 High Profile 中的一个可选的高级特性，复杂度更高，但压缩效率也更高（通常能比 CAVLC 节省 10%-15% 的码率）。

下面我们来详细解析这两种方法的原理。



### 1. 为什么需要熵编码？(The "Why")



经过量化后，变换系数矩阵呈现出几个非常有利于压缩的统计特性：

1. **大量的零**：大部分高频系数都变成了 0。
1. **拖尾的 1**：非零系数中，有大量的 `+1` 和 `-1`。
1. **幅值集中于低值**：非零系数的绝对值通常很小。
1. **非零系数集中在左上角**：经过 Zig-zag 扫描后，非零系数大多出现在序列的开头。

熵编码的核心思想就是利用这些统计特性，为**出现概率高**的符号（或事件）分配**短码字**，为**出现概率低**的符号分配**长码字**，从而达到压缩数据的目的。这与摩斯电码中字母 'e'（最常用）的编码最短是同一个道理。

**流程图 (ASCII Art):**

```
+-------------------+     +---------------------+     +-----------------+
| Quantized Coeffs  | ->  | Zig-zag Scanning    | ->  | Entropy Coding  | -> Bitstream
| (many zeros)      |     | (Group non-zeros)   |     | (CAVLC or CABAC)|
+-------------------+     +---------------------+     +-----------------+
```



### 2. CAVLC (基于上下文自适应的可变长度编码)



CAVLC 是一种专门为量化后的 4x4 或 2x2 块系数设计的编码方案。它不是一个简单的 VLC（像 Huffman 编码），而是巧妙地结合了多个元素的上下文信息来进行自适应编码。

CAVLC 的编码过程可以分解为以下几个步骤：

1. **编码非零系数的数量 (TotalCoeffs) 和拖尾 '1' 的数量 (TrailingOnes)**
   + 首先，从 Zig-zag 扫描后的序列末尾开始反向读取。
   + **TrailingOnes**: 统计末尾有多少个连续的 `+1` 或 `-1`。例如，序列 `... 3, -1, 1, -1, 0, 0`，则 `TrailingOnes` 为 3。
   + **TotalCoeffs**: 统计整个块中非零系数的总数。
   + CAVLC 使用一个二维查找表 `coeff_token`，根据 `TotalCoeffs` 和 `TrailingOnes` 的组合来查找一个特定的码字。这个 `coeff_token` 码字非常高效，用一个很短的比特串就同时传递了两个关键信息。之所以这样做，是因为统计发现 `TotalCoeffs` 和 `TrailingOnes` 的值之间有很强的相关性。
1. **编码每个拖尾 '1' 的符号 (Sign of TrailingOnes)**
   + 对于每个拖尾 '1'，用 1 比特来表示其符号（0 代表 `+`, 1 代表 `-`）。
1. **编码除拖尾 '1' 外的其他非零系数的幅值 (Levels)**
   + 从序列末尾（最后一个拖尾 '1' 之后）向前编码。
   + 每个系数的幅值（Level）使用一种称为 **Golomb-Rice** 的编码方式。这种编码方式对幅值小、概率分布有偏的数值特别高效。
1. **编码最后一个非零系数前 '0' 的个数 (TotalZeros)**
   + 统计从序列开头到最后一个非零系数之间所有 '0' 的总数。
   + 使用专门的 VLC 表，根据 `TotalCoeffs` 来查找对应的码字。
1. **编码每个非零系数前连续 '0' 的个数 (Runs)**
   + 从最后一个非零系数开始，反向编码每个非零系数前面有多少个连续的 '0'（Run）。
   + 编码 `Run` 的 VLC 表是自适应的：它会根据**剩下还需要编码的 '0' 的数量**来动态选择使用哪个 VLC 表。例如，如果剩下的 '0' 很少了，那么一个长的 `Run` 出现的概率就很低，编码器就会选择一个对短 `Run` 更有利的码表。**这就是 CAVLC 中“上下文自适应”的主要体现之一。**

**CAVLC 总结：**

+ **优点**：实现相对简单，不需要复杂的乘法运算，计算速度快。
+ **缺点**：
  + 压缩效率不如 CABAC。
  + 它的自适应性是基于一些预定义的规则和查找表，不够灵活。
  + 只能用于残差系数编码，其他语法元素（如 MVD, MB type）需要使用别的 VLC 编码。



### 3. CABAC (基于上下文自适应的二进制算术编码)



CABAC 是 H.264 中最高效的熵编码方法，它的压缩性能之所以优越，源于其三个核心步骤：

1. **二值化 (Binarization)**
   + 算术编码器本身只能处理二进制符号（0 或 1）。因此，在编码任何语法元素（例如，一个值为 `5` 的运动向量差 `mvd`）之前，必须先将其转换成一个二进制串。这个过程称为二值化。
   + H.264 为不同的语法元素定义了不同的二值化方案，最常用的是**一元码 (Unary)** 和**指数哥伦布码 (Exp-Golomb)** 的组合。
   + 例如，一个正整数 `x` 可以用 `x-1` 个 '1' 后面跟一个 '0' 来表示（一元码）。`5` -> `11110`。
1. **上下文建模 (Context Modeling)**
   + 这是 CABAC “上下文自适应”的核心。对于二值化后的比特串中的**每一位 (bin)**，CABAC 都会根据已经编码过的、与之相关的语法元素信息，来选择一个**概率模型 (Context)**。
   + 这个概率模型本质上是预测当前这位是 '0' 还是 '1' 的概率。例如，在编码一个块的 `significant_coeff_flag`（表示当前位置的系数是否为零）时，CABAC 会查看其**上方**和**左侧**相邻块的对应系数是否为零。如果它们都不为零，那么当前系数也不为零的概率就很高。
   + H.264 标准为不同的语法元素和不同的 `bin` 精心设计了数百个上下文模型。每个模型内部维护着当前 '1' 和 '0' 出现的概率状态。在编码完一个 `bin` 后，对应的模型会根据实际编码的值（是 '0' 还是 '1'）来**更新**自己的概率状态。这样，概率模型就能动态地适应视频内容的局部统计特性。
1. **二进制算术编码 (Binary Arithmetic Coding)**
   + 这是最后的编码引擎。与 VLC 不同，算术编码不是将一个符号映射到一个固定的码字。
   + 它将整个符号序列映射到 `[0, 1)` 区间内的一个**浮点数**。
   + **工作原理（简化版）**：
     + 开始时，编码范围是 `[0, 1)`。
     + 编码第一个 `bin` 时，根据上下文模型提供的概率 p_0 和 p_1（p_0+p_1=1），将当前范围分割成两部分。例如，`[0, p_0)` 对应 '0'，`[p_0, 1)` 对应 '1'。
     + 如果实际要编码的 `bin` 是 '0'，就选择 `[0, p_0)` 作为新的编码范围；如果是 '1'，就选择 `[p_0, 1)`。
     + 对后续的每一个 `bin`，都重复这个过程：根据其概率模型，在**当前**的编码范围内继续进行分割和选择。
     + 编码完所有 `bin` 后，最终会得到一个非常小的范围。在这个范围内**任选一个小数**（用二进制表示），这个二进制小数就是整个序列的编码结果。

**ASCII 图解算术编码过程：**

```
Initial Range: [0.0, 1.0)
+-------------------------------------------------------------+

Bin 1 ('1'), P(1)=0.4, P(0)=0.6
          [0.0, 0.6) for '0' | [0.6, 1.0) for '1'
+----------------------------+--------------------------------+
                             ^
                             New Range: [0.6, 1.0)

Bin 2 ('0'), in new range, P(1)=0.5, P(0)=0.5
          [0.6, 0.8) for '0' | [0.8, 1.0) for '1'
+----------------------------+------------------+--------------+
                             ^
                             New Range: [0.6, 0.8)

... and so on. The range gets progressively smaller.
```

**CABAC 总结：**

+ **优点**：
  + **极高的压缩效率**：概率估计非常精准，并且算术编码能以接近信息熵理论极限的效率进行编码。
  + **统一的框架**：可以对所有语法元素（残差、MVD、宏块类型等）进行统一编码。
+ **缺点**：
  + **计算复杂度高**：涉及到大量的状态更新和条件判断。尤其是在解码端，每个 `bin` 的解码都依赖于前一个 `bin` 的解码结果，这使得并行处理变得非常困难。
  + **需要浮点（或模拟浮点）运算**：虽然 H.264 的算术编码引擎被设计为可以用整数运算来模拟，但其逻辑仍然比 CAVLC 复杂得多。



### 5. CAVLC vs. CABAC: 对 C++ 开发者的启示



| 特性             | CAVLC (可变长度编码)                                   | CABAC (算术编码)                                   |
| ---------------- | ------------------------------------------------------ | -------------------------------------------------- |
| **压缩效率**     | 好                                                     | **极好** (比 CAVLC 高 10%-15%)                     |
| **计算复杂度**   | **低**                                                 | 高 (大约是 CAVLC 的 2-3 倍)                        |
| **适用 Profile** | Baseline, Main, High 等所有 Profile                    | Main, High 等高级 Profile (可选)                   |
| **实现难度**     | 中等，主要是查表和状态机管理。                         | **高**，需要精确实现上下文模型更新和算术编码引擎。 |
| **并行性**       | 较好，块与块之间独立。                                 | **差**，`bin` 与 `bin` 之间存在强数据依赖。        |
| **应用场景**     | 实时通信、视频会议（对延迟敏感，计算资源受限的场景）。 | 视频存储、广播、流媒体（追求最高压缩率的场景）。   |