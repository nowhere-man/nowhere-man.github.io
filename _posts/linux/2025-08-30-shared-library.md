---
layout: post
title: Linux可执行文件载入和执行过程
slug: dynamic-library-and-loading
categories: [Linux]
tags: [Linux]
---



## ELF文件

Linux 下标准的可执行文件格式是 ELF。ELF (Executable and Linking Format) 是一种对象文件的格式。在 linux 系统中，一个ELF文件主要用来表示3种类型的文件
+ 可执行文件 : 被操作系统中的加载器从硬盘中读取，加载到内存中去执行。
+ 目标文件(.o) ：被链接器读取，用来产生一个可执行文件或者共享文件。
+ 共享文件(.so) ：在动态链接的时候，由 ld-linux.so 来读取。





## 可执行文件的加载

当我们在 Linux 下的bash下输入一个命令执行可执行程序时，
1. bash 进程会**调用`fork()`创建一个新的进程**，
2. 新的进程调用`execve()`系统调用来执行指定的可执行程序。
3. bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户的输入。

execve()的系统调用原型：
```c
// filename: 可执行程序文件名
// argv: 执行参数
// envp: 环境变量
int execve(const char *filename, char *const argv[], char *const envp[]);
```

execve()的执行流程：
1. 校验ELF文件：内核首先会读取文件开头的特殊字节序列，用于标识文件类型。ELF文件的魔数是`\x7fELF`。
2. 权限检查。
3. 清理旧内存：内核会释放掉子进程（fork()从shell克隆出来的进程）旧有的内存空间，包括栈、堆和代码段。
4. 解析ELF文件：内核开始解析ELF文件的程序头表。这个表包含了所有需要被加载到内存中的段的信息，比如代码段（.text）、数据段（.data）等。
5. 内存映射：内核为这些段在进程的虚拟地址空间中分配内存，并使用mmap() 系统调用将ELF文件中的相应部分映射到这些虚拟地址上。这是一种“按需加载”的策略，文件内容并不会一次性全部加载到物理内存，而是在需要时才从磁盘读取。
6. 设置栈和堆： 内核会为新的进程设置一个新的栈（stack）和一个空的堆（heap）。
7. 加载器定位： 如果可执行文件是动态链接的，内核会在ELF头的PT_INTERP段中找到动态链接器（/lib64/ld-linux-x86-64.so.2）。内核会把动态链接器本身也加载到内存中。
8. 将系统调用的返回地址修改为 ELF 可执行文件的入口点。
    + 若是静态链接，则入口地址为 ELF 文件的文件头中 e_entry 所指的地址
    + 对于动态链接的ELF可执行文件，程序入口点是动态链接器。
9. 跳转到入口地址，新的程序开始执行，ELF 可执行文件装载完成。





## 动态库的加载

1. 控制权转移： 在将可执行文件和动态链接器加载到内存后，内核不会直接将控制权交给主程序，而是先转移给 动态链接器。
2. 解析依赖： 动态链接器的工作是解析主程序和它依赖的所有共享库（.so 文件）。它会检查主程序的 .dynamic 段，找到所有需要的库，比如 libc.so.6。
3. 加载共享库： 链接器会使用 mmap() 将这些共享库也加载到进程的虚拟地址空间中。
4. 符号重定位： 共享库被加载到随机的虚拟地址上。链接器需要进行 重定位（relocation），来修正主程序和这些库之间所有函数调用和全局变量引用的地址。这是通过解析 ELF 文件的 重定位表（Relocation Table） 来完成的。






## 程序的运行

1. 初始化： 链接器完成所有共享库的加载和重定位后，它会调用共享库中的 初始化函数（_init），这些函数通常用于设置库内部的一些全局状态。
1. 入口点： 链接器最后将控制权转移给主程序的真正入口点。这个入口点通常是 C 运行库（如 glibc）中的 _start 函数。
1. 调用`main()`： _start 函数会进行一些最后的初始化工作，比如设置命令行参数 argc 和 argv，然后调用我们熟悉的 main() 函数，程序正式开始执行。

