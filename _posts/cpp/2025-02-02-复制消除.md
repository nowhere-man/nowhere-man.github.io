---
layout: post
title: 复制消除
slug: copy-elision
categories: [C++总结]
tags: [C++]
---

## 复制消除（copy elision）
这项优化技术的中心思想是：**一个函数若直接返回类对象，一般会生成临时类对象变量，需多次调用拷贝构造函数（copy constructor）造成效率低下，编译器对此优化，省略其中的拷贝构造环节，达到提升效率的目的。**

本文以下面的类为例进行说明
```cpp
struct Foo {
   Foo() { std::cout << "Constructed" << std::endl; }
   Foo(const Foo &) { std::cout << "Copy-constructed" << std::endl; }
   Foo(Foo &&) { std::cout << "Move-constructed" << std::endl; }
   ~Foo() { std::cout << "Destructed" << std::endl; }
};

```
使用 `-fno-elide-constructors` 编译选项可以告诉编译器不要执行复制消除的动作。
### 命名返回值优化（Named Return Value Optimization，NRVO）
```cpp
Foo f()
{
  Foo foo;
  return foo;
}
int main()
{
    Foo foo = f();
}
```
output:
```
Constructed
Move-constructed
Destructed
Move-constructed
Destructed
Destructed
```

### 返回值优化（Return Value Optimization，RVO）
```cpp
Foo f()
{
  return Foo();
}
int main()
{
    Foo foo = f();
}
```
output:
```
Constructed
Move-constructed
Destructed
Move-constructed
Destructed
Destructed
```
这个优化节省了两次（移动）构造函数的调用，第一次复制动作是将局部对象 foo 复制到函数 f() 返回值的临时对象中，第二次复制动作是将函数返回的临时对象复制到 main() 函数中的 foo 对象中。
### 临时对象传值（Passing a Temporary by Value）
```cpp
void f(Foo f)
{
    std::cout << "Fn" << std::endl;
}

int main()
{
    f(Foo());
}

```
output:
```
Constructed
Move-constructed
Fn
Destructed
Destructed
```
##  有保证的复制消除（Guaranteed Copy Elision）
有保证的复制消除提案强调了对于当前这种状况（译者注：就是非强制的复制消除策略）的几个问题。如果对复制消除没有保证（仅仅是允许），就无法摆脱拷贝构造函数和移动构造函数被调用的事实，因为消除动作没有发生，这是主要问题。这也阻止了一些不可移动（non-movable）的类型被当作函数返回值传递，比如工厂模式。

```cpp
struct Foo {
  Foo() { std::cout << "Constructed" << std::endl; }
  Foo(const Foo &) = delete;
  Foo(const Foo &&) = delete;
  ~Foo() { std::cout << "Destructed" << std::endl; }
};

Foo f() {
  return Foo();
}

int main() {
  Foo foo = f();
}

```

上述代码，在c++11中无法通过编译，但是在c++17中可以。

这个提案的全称是“通过简化的值的分类保证复制消除”。为了实现有保证的复制消除，提案建议区分 prvalue（纯右值）表达式和通过它们初始化的临时对象。更具体地说，一个广义上的左值（generalized lvalue） glvalue 被定义为对象的位置，而一个纯右值 prvalue 被定义为对象的初始值设置者。

如果一个纯右值 prvalue 被用作另一个同一类型对象的初始值设置器（initializer），则直接对这个对象进行初始化，相应的结果就是通过函数返回值（临时对象）的初始化变成了直接初始化（译者注：函数调用表达式左边的对象原本要通过函数返回产生的临时对象初始化，现在变成直接对这个对象进行初始化），避免了拷贝或移动，这就意味着不需要访问对象的拷贝构造函数或移动构造函数。

第二个结果就是即使有了“有保证的复制消除”， C++ 17 中的 NVRO 也不会发生任何变化，正如前面所述，这个更改（译者注：指增加“有保证的复制消除”）只涉及纯右值，对 NVRO 来说，那个命名的值是个广义上的左值（glvalue），所以不受影响。提案的作者也承认了这一点，但是选择将其排除在提案之外。