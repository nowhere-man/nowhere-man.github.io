---
layout: post
title: C++并发编程 1：基础
slug: cpp-concurrency-basics
categories: [C++]
tags: [C++并发编程]
---

## 为什么使用并发
+ **分离关注点**
    通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。

    用并发技术分离关注点的依据是设计理念，而不是以增加运算吞吐量为目的。
+ **性能提升**
    + 任务并行：将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。
    + 数据并行：每个线程在不同的数据部分上执行相同的操作。

## 什么情况避免使用并发
不使用并发的唯一原因就是**收益比不上成本**。

## C++中的并发库


### C++ 11
C++ 11引入了一整套内存模型和线程支持库。
+ `std::thread`: 创建和管理线程。
+ `std::mutex`: 互斥锁。
+ `std::recursive_mutex`：递归锁。
+ `std::lock_guard` 和 `std::unique_lock`: RAII的锁管理类。
+ `std::condition_variable`: 条件变量。
+ `std::atomic`: 原子操作库。
+ `std::future`、`std::promise`和`std::async:`: 异步任务。

### C++ 14
+ `std::shared_timed_mutex`:引入了一种支持多读单写的互斥锁。
+ `std::shared_lock`: 同时管理多个互斥锁。

### C++ 17
+ 并行STL算法。
+ `std::scoped_lock`
+ `std::shared_mutex`

### C++ 20
+ coroutines：协程支持。
+ `std::jthread`
+ `std::barrier`和`std::latch`
+ `std::counting_semaphore`和`std::binary_semaphore`：信号量。



### C++线程库的效率
1. 在实现相同功能的前提下，直接使用底层API相比C++线程库并不会带来过多的性能收益。
1. 零成本抽象：未被使用的功能完全不产生额外开销。