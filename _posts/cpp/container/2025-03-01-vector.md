---
layout: post
title: STL容器：vector核心总结
slug: stl-vector
categories: [C++总结]
tags: [STL]
---
vector是一种封装**动态数组**的**序列**容器，在内存中连续排列。

## vector的size
vector对象大小是固定的。
```cpp
class vector {
...
protected:
    iterator start;           // 目前使用空间的头
    iterator finish;          // 目前使用空间的尾
    iterator end_of_storage;  // 目前可用空间的尾
...
};
```

```cpp
std::vector<int> v;

// 24
std::cout << sizeof(v) << std::endl;
```

## vector的构造函数
```cpp
vector<int> v1;                                  // 无元素
vector<int> v2 {1, 2, 3, 4, 5};                  // 列表初始化
vector<int> v3(4);                               // 4个元素，初始值为0
vector<int> v4(5, 3);                            // 5个元素，初始值为3
vector<int> v5(v4);                              // 使用另外一个vector拷贝构造
vector<int> v6(std::move(v5));                   // 使用另外一个vector移动构造
vector<int> v7(arr1, arr1+5);                    // 使用指针初始化
vector<int> v8(v4.begin(), v4.end());            // 使用迭代器初始化[左闭,右开）
```

## vector的成员函数

**访问**：

+ front()
+ back()
+ data()
+ at()：`at()`会检查边界，如果索引超出有效范围，`at()`会抛出out_of_range异常。
+ operator[]

**修改**:

+ push_back()
+ pop_back()
+ insert()：`insert(idx, val)`是在idx之前插入val。insert()会导致从第idx起后面的所有元素
+ emplace()：`emplace(idx, Args&&... args)`是在idx之前插入val，args会直接转发给构造函数。
+ emplace_back()
+ clear()：清除所有元素，clear()完成后size()为0。
+ erase()：`erase(idx)`移除idx所在的元素； `erase(begin, end)`移除范围内的元素，不包括end。

**容量**：

+ empty()
+ size()
+ max_size():容器的理论极限size，和系统或库实现相关。
+ resize()：增加或减小size(),可能会改变capacity。
+ reserve()：增加capacity, 不修改size，`reserve(new_cp)`只在new_cp大于原有capacity时才扩容。
+ capacity()
+ shrink_to_fit()：将capacity减小至size，但是不是强制的，能否达成依赖于实现。

**迭代器**：
+ begin() 和 end()
+ cbegin() 和 cend()
+ rbegin() 和 rend()：`end()`和`cend()`是末尾元素的下一个元素， `rend()`是末尾元素， `rbegin()`是首元素的前一个元素。


## vector的扩容机制

在插入元素时，如果size==capcaity时进行扩容操作：
1. 开辟一块更大的内存空间
2. 将原来的元素复制到新的内存空间（优先尝试移动构造）
3. 释放原有空间
4. 将新的元素插入到新的内存空间中

扩容特点：
+ 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都将失效。
+ 初始时刻vector的capacity为0，插入第一个元素后capacity增加为1。
+ 不同的编译器实现的扩容方式不一样，MSVC中以1.5倍扩容，GCC以2倍扩容。

**为什么使用成倍扩容策略：**
使用成倍扩容策略，平均下来插入一个元素的平均时间复杂度为O(1)。

**为什么使用1.5倍或2倍扩容：**
理想的扩容方案是在第N次扩容时可以复用之前N-1次释放的空间。如果按照2倍方式扩容，第i次扩容空间大小如下：
```
1 2 4 8 16 32 64 ...
```
可以看到，每次扩容时，前面释放掉的空间都不能使用。

比如：第4次扩容时，假设前3次空间已经释放，即释放的空间有1+2+4=7，而第四次需要8，导致无法使用之前的空间。

但使用使用1.5倍扩容时，在几次扩容后，就可能重用之前的内存空间。

## 参考
+ [面试题：C++vector的动态扩容，为何是1.5倍或者是2倍](https://blog.csdn.net/qq_44918090/article/details/120583540)
+ [c++ vector的扩容机制](https://blog.csdn.net/qq_41021141/article/details/131329403)
