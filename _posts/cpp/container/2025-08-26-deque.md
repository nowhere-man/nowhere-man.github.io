---
layout: post
title: STL容器：deque核心总结
slug: stl-deque
categories: [C++总结]
tags: [STL]
---
deque属于顺序容器的一种，是一个双端队列，它允许在容器的两端进行快速插入和删除元素的操作。

deque虽然支持像vector一样样的按索引访问，但其随机访问效率不如vector。

std::deque适用于需要在首尾两端频繁进行插入和删除的场景。

## deque的底层实现
deque的元素不连续存储，而是由**多个固定大小的连续内存块**组成，并通过一个**主控map**来管理。

` _M_map`是一个指针数组，其中每个元素（node）指向一块内存块。内存块才是deque 的储存空间主体。

deque：
+ map：记录每个内存块的地址。
+ map_size：内存块的个数。
+ start迭代器：记录着map数组中首个内存块的信息。
+ finish迭代器：记录着map数组中最后一个内存块的信息。
```cpp
template<typename _Tp> class _Deque_base {
    typedef _Deque_iterator<_Tp> iterator;
protected:
	  _Tp** _M_map;
	  size_t _M_map_size;
	  iterator _M_start;
	  iterator _M_finish;
};
```
迭代器：
+ cur：指向当前迭代器所代表的元素。
+ first：指向当前数据块的起始位置。
+ last：指向当前数据块的末尾位置。
+ node：指向map数组中存储的指向当前数据块的位置。
```cpp
template<class _Tp> struct _Deque_iterator {
	typedef _Tp** _Map_pointer;

	_Tp* _M_cur;
	_Tp* _M_first;
	_Tp* _M_last;
	_Map_pointer _M_node;
};
```
![](https://i-blog.csdnimg.cn/blog_migrate/ca3bc074804f55cc135afe434135d43f.png)

### 初始状态
初始时，_M_map成员为nullptr , _M_map_size为0。

### 插入元素
以尾部插入为例：

1. 首先，deque 检查 _M_finish._M_cur 是否等于 _M_finish._M_last。如果相等，说明当前数据块已满。
1. 如果数据块未满：新元素直接添加到 _M_finish._M_cur 指向的位置，然后将 _M_finish._M_cur 向后移动一位。
1. 如果数据块已满：
  + deque 需要移动到下一个数据块。它通过 _M_finish._M_node 指针向后移动一位，找到 _M_map 中下一个可用的指针。
  + 如果 _M_map 中有空闲块，就直接使用。如果没有，deque 会分配一个新块。
  + 然后，将新元素插入到新块的开头，并更新 _M_finish 迭代器的 _M_node 和 _M_cur 指针。

当`_M_map`满了后，会对其扩容。

头部插入与尾部插入类似，但操作的是_M_start，并且头部插入是从后往前插入。

### 删除元素
以尾部删除为例：
+ 首先，将 _M_finish._M_cur 指针向前移动一位，使其指向最后一个元素。
+ 如果 _M_finish._M_cur 现在等于 _M_finish._M_first，这意味着当前数据块中的元素已被全部删除。
+ 在这种情况下，deque 会释放这个数据块，并将 _M_finish 迭代器的 _M_node 指针向前移动，指向 _M_map 中的前一个数据块。

### 随机访问
对于dq[i]：
1. 计算 _M_start 迭代器的块内偏移： `start_offset_in_block = _M_start._M_cur - _M_start._M_first`
1. 计算i相对deque开头的总偏移量： `total_offset = i + start_offset_in_block`
1. 计算数据块索引：`block_index = total_offset / map_size`
1. 定位数据块的指针：`target_map_node = _M_start._M_node + block_index`
1. 计算块内偏移：`offset_in_block = total_offset % block_size`
1. 定位元素的指针：`target_element_ptr = *target_map_node + offset_in_block`

## deque的size
deque对象大小是固定的。

```cpp
std::deque<int> dq;
std::cout << sizeof(dq) << std::endl; // 输出80
```


## deque的构造函数
deque的构造函数和vector类似：
```cpp
deque<int> v1;                                  // 无元素
deque<int> v2 {1, 2, 3, 4, 5};                  // 列表初始化
deque<int> v3(4);                               // 4个元素，初始值为0
deque<int> v4(5, 3);                            // 5个元素，初始值为3
deque<int> v5(v4);                              // 使用另外一个vector拷贝构造
deque<int> v6(std::move(v5));                   // 使用另外一个vector移动构造
deque<int> v7(arr1, arr1+5);                    // 使用指针初始化
deque<int> v8(v4.begin(), v4.end());            // 使用迭代器初始化[左闭,右开）
```

## deque的成员函数

**访问**：

+ front()
+ back()
+ at()：`at()`会检查边界，如果索引超出有效范围，`at()`会抛出out_of_range异常。
+ operator[]

**修改**:

+ push_back()
+ push_front()
+ pop_back()
+ pop_front()
+ emplace_back()
+ emplace_front()
+ insert()：`insert(idx, val)`是在idx之前插入val。insert()会导致从第idx起后面的所有元素
+ emplace()：`emplace(idx, Args&&... args)`是在idx之前插入val，args会直接转发给构造函数。
+ clear()：清除所有元素，clear()完成后size()为0。
+ erase()：`erase(idx)`移除idx所在的元素； `erase(begin, end)`移除范围内的元素，不包括end。

**容量**：

+ empty()
+ size()
+ max_size():容器的理论极限size，和系统或库实现相关。
+ shrink_to_fit()：释放未使用的内存块。

**迭代器**：
+ begin() 和 end()
+ cbegin() 和 cend()
+ rbegin() 和 rend()：`end()`和`cend()`是末尾元素的下一个元素， `rend()`是末尾元素， `rbegin()`是首元素的前一个元素。


## 参考
+ [deque的介绍 | 对其内存布局进行图解](https://blog.csdn.net/m0_56257585/article/details/124115398)
