---
layout: post
title: C++关键字-x_cast
slug: x_cast
categories: [C++总结]
tags: [C++关键字]
---

## static_cast
static_cast相当于传统的C语言里的强制转换。
主要用于：
1. 用于基本数据类型之间的转换，如把int转换成char，这种转换的安全性需要开发人员来保证。
2. 把空指针转换成目标类型的空指针。
3. 把任何类型的表达式转换成void类型。
4. 用于基类和派生类之间指针或引用的转换。
**进行上行转换（派生类指针或引用转基类指针或引用）是安全的；**
**进行下行转换（基类指针或引用转派生类指针或引用）时，由于没有动态类型检查，所以是不安全的。**

注意：static_cast不能转换掉变量的const、volatile属性。

## const_cast

```cpp
const_cast<type*>(e)
const_cast<type&>(e)
```

用于修改类型的const或volatile属性。
+ 常量指针被转化成非常量的指针，并且仍然指向原来的对象；
+ 常量引用被转换成非常量的引用，并且仍然指向原来的对象；

```cpp
const int g = 20;
//去掉const常量const属性
int *h = const_cast<int*>(&g);

const int g = 20;
//去掉const引用const属性
int &h = const_cast<int &>(g);

const char *g = "hello";
//去掉const指针const属性
char *h = const_cast<char *>(g);
```
## reinterpret_cast

interpret是“解释，诠释”的意思，加上前缀“re”，就是“重新诠释”的意思

**rienterpret_cast 运算符并不会改运算对象的值，而是对该对象从low-level上进行重新解释**

**type必须是一个指针、引用、算术类型、函数指针或者成员指针。**

可以用于：
+ 不同类型的指针之间的转换
+ 指针和能容纳指针的类型之间的转换（比如将`int`类型强转成`int*`类型）
+ 不同类型的引用之间的转换

## dynamic_cast
type必须是一个类类型

```cpp
dynamic_cast<type*>(e)
dynamic_cast<type&>(e)
dynamic_cast<type&&>(e)
```
dynamic_cast主要用于：
+ 基类和派生类之间指针或引用的转换
+ 在同一继承层级的不同派生类之间指针或引用的转换

由于具有运行时类型检查，因此**可以保证下行转换(基类指针或引用转派生类指针或引用)的安全性**

为了使 `dynamic_cast` 能够进行运行时类型检查，必须满足：
**基类必须有虚函数，以支持运行时类型识别 (RTTI)**

对于上行转换，static_cast和dynamic_cast效果一样，都安全。

安全性：
+ 转换成功就返回转换后的正确类型指针
+ 如果指针转换失败，则返回NULL；如果引用转换失败，将抛出`std::bad_cast`异常
+ static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL