---
layout: post
title: C++关键字-explicit
slug: explicit
categories: [C++总结]
tags: [C++关键字]
---

explicit关键字**只能用于修饰类构的造函数**，表明该构造函数是**显式的**，**不能用于隐式转换和复制初始化。**
1. 该关键字只能用来修饰类内部的构造函数；
2. 禁止隐式调用拷贝构造函数  ；
3. 禁止类对象之间的隐式转换；
4. 一般只用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的。

在C++类的实例化过程中，**存在一种隐式转换**
```cpp
#include <iostream>
using namespace std;

class Point {
public:
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) {}
};

void displayPoint(const Point& p)
{
    cout << "(" << p.x << "," << p.y << ")" << endl;
}

int main()
{
    // 显式调用
    Point p0(1);
    Point p1(1, 2);
    Point p2 = Point(1, 2);
    displayPoint(Point(1, 2));

    // 隐式转换
    Point p3 = 1;
    Point p4 = (1, 2);
    displayPoint(1);
    displayPoint((1, 2));
    displayPoint({1, 2});
}
```
为什么隐式转换的例子都可以通过编译：如果构造函数只有一个参数，那么编译的时候就会有一个缺省的转换操作：将改构造函数对应数据类型的数据转换为该类的对象。

比如`Point p3 = 1;` 实际上等同于：
```cpp
Point tmp(1);
Point p3 = temp;
```
加上explicit后，禁止隐式转换，编译无法通过。

```cpp
class Point {
public:
    int x, y;
    explicit Point(int x = 0, int y = 0) : x(x), y(y) {}
};
```
为什么要加explicit:
+ 避免意外的类型转换，导致语义的混淆。
+ 增加可读性。
+ 避免潜在的新能开销。
+ 
