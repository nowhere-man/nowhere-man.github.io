---
layout: post
title: C++关键字-static
slug: static
categories: [C++总结]
tags: [C++关键字]
---

## 全局静态变量
**内存中的位置：** 静态存储区，在整个程序运行期间一直存在。

**初始化**：未经初始化的全局静态变量会被自动初始化为0。

**作用域**：从定义之处开始，到文件结尾。（全局静态变量在声明他的文件之外是不可见的）

## 局部静态变量
**内存中的位置：** 静态存储区，在整个程序运行期间一直存在。

**初始化**：执行到该语句时进行初始化，未经初始化的局部静态变量会自动初始化为0。

**作用域**：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

## 静态函数
在函数返回类型前加static，函数就定义为静态函数。非静态函数的定义和声明在默认情况下都是extern的，但**静态函数只是在声明他的文件当中可见，不能被其他文件所用。**

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

用法：
+ 不要再头文件中**声明**static的全局函数！！！
+ 不要在cpp内**声明**非static的全局函数！！！

## 类的静态数据成员
在类中，**静态成员可以实现多个对象之间的数据共享**，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员，而不是某个对象的成员。**
对多个对象来说，**静态数据成员只存储一处**，供所有对象共用。

**sizeof 运算符不会计算静态成员变量**。

静态数据成员是静态存储的，所以**必须对它进行初始化**。

静态成员初始化与一般数据成员初始化不同:
1. 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
2. 初始化时不加该成员的访问权限控制符private，public等；       
3. 初始化时使用作用域运算符来标明它所属类；
**<数据类型> <类名>::<静态数据成员名> = <值>**

为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。

```cpp
class Foo {
public:
    static int a; // 只是声明，不是定义，必须在类外定义才能使用
    static int b {2}; // 编译错误， 静态成员变量不能类内初始化
    static const int c {2} // ok，const的静态成员变量可以类内初始化
    static const int d;    // ok, const的静态成员变量也可以只声明，但必须在类外定义。
};
int Foo::a = 2;       // 不用再加static关键字
const int Foo::d = 2; // 但必须加const关键字
```


## 类的静态成员函数
**类的静态成员函数是属于整个类，而非类的对象**，所以它**没有this指针**，所以它**仅能访问类的静态数据和静态成员函数**。

不能将静态成员函数定义为虚函数。
