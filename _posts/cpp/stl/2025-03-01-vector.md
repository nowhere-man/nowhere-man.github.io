---
layout: post
title: vector核心总结
slug: stl-vector
categories: [C++总结]
tags: [STL]
---
vector是一种封装**动态数组**的**序列**容器，在内存中连续排列。

## vector的size
vector对象大小是固定的。
```cpp
int main()
{
    // 24
    std::vector<int> v1;
    std::vector<double> v2;

    // 24
    std::cout << sizeof(v1) << std::endl;
    // 24
    std::cout << sizeof(v2) << std::endl;
}
```

## vector的构造函数
```cpp
vector<int> v1;                                  // 无元素
vector<int> v2 {1, 2, 3, 4, 5};                  // 列表初始化
vector<int> v3(4);                               // 4个元素，初始值为0
vector<int> v4(5, 3);                            // 5个元素，初始值为3
vector<int> v5(v4);                              // 使用另外一个vector拷贝构造
vector<int> v6(std::move(v5));                   // 使用另外一个vector移动构造
vector<int> v7(arr1, arr1+5);                    // 使用指针初始化
vector<int> v8(v4.begin(), v4.end());            // 使用迭代器初始化[左闭,右开）
```

## vector的成员函数

访问：
+ front()
+ back()
+ data()
+ at()：`at()`会检查边界，如果索引超出有效范围，`at()`会抛出out_of_range异常。
+ operator[]
  
修改:
+ push_back()
+ pop_back()
+ insert()：`insert(idx, val)`是在idx之前插入val。insert()会导致从第idx起后面的所有元素
+ emplace()：`emplace(idx, Args&&... args)`是在idx之前插入val，args会直接转发给构造函数。
+ emplace_back()
+ clear()：清除所有元素，clear()完成后size()为0。
+ erase()：`erase(idx)`移除idx所在的元素； `erase(begin, end)`移除范围内的元素，不包括end。


容量：
+ empty()
+ size()
+ max_size():容器的理论极限size，和系统或库实现相关。
+ resize()：增加或减小size(),可能会改变capacity。
+ reserve()：增加capacity, 不修改size，`reserve(new_cp)`只在new_cp大于原有capacity时才扩容。
+ capacity()
+ shrink_to_fit()：将capacity减小至size，但是不是强制的，能否达成依赖于实现。

迭代器：
+ begin() 和 end()
+ cbegin() 和 cend()
+ rbegin() 和 rend()：`end()`和`cend()`是末尾元素的下一个元素， `rend()`是末尾元素， `rbegin()`是首元素的前一个元素。


## vector的扩容机制

在插入元素时，如果size==capcaity时进行扩容操作：
1. 开辟一块更大的内存空间
2. 将原来的元素复制到新的内存空间（优先尝试移动构造）
3. 释放原有空间
4. 将新的元素插入到新的内存空间中

扩容特点：
+ 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都将失效。
+ 初始时刻vector的capacity为0，插入第一个元素后capacity增加为1。
+ 不同的编译器实现的扩容方式不一样，MSVC中以1.5倍扩容，GCC以2倍扩容。

为什么使用成倍扩容策略：
