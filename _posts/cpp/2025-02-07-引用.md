---
layout: post
title: 左值引用和右值引用
slug: reference
categories: [C++总结]
tags: [C++]
---

## 左值引用
左值引用就是左值的别名，**不是变量的别名，而是地址的别名**，是与地址建立的一种映射关系。我们可以通过不同的别名访问同一块地址空间。

左值引用并非对象，只是为一个已经存在的对象所起的另外一个名字。

左值引用必须初始化，因为无法令左值引用重新绑定到另外一个对象。一旦初始化完成，左值引用将和他的初始值对象一直绑定在一起。

```cpp
#include <iostream>
int main()
{
    int x = 1;
    int &y = x;

    // output: 0x7ffc224801bc 0x7ffc224801bc
    std::cout << &x << " " << &y << std::endl;
}
```

## 右值引用
右值引用是 C++11 为了实现**移动语义**（move semantic）和**完美转发**（perfect forwarding）而设计出来的新的数据类型，它的主要目的有两个方面：
- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

右值引用，简单说就是绑定在右值上的引用，右值引用必须立即进行初始化操作，且只能使用右值进行初始化。
```cpp
int && a = 10;
```

和常量左值引用不同的是，右值引用是一个变量，右值变量是一个左值，它有固定的内存地址，所以可以对右值进行"修改"：
```cpp
int && a = 10;
a = 100;
// output: 100
cout << a << endl;
```
等价于
```cpp
// 10是一个字面量，它本身没有内存。为了让引用a能绑定到一个实体，编译器会在栈上创建一个匿名的临时变量，并将10的值存储在这个临时变量中。
int _temp = 10;
int && a = _temp;

_temp = 100;
```
那么`int && a = 10`和`int a = 10`，其中a都是左值，有什么区别呢：
+ `int a = 10`遵循值语义，10是放到了a所指向的内存。
+ `int && a = 10`遵循引用语义，a本身不是一个对象，它只是一个别名，指向了另外一个对象。只是这个对象是临时的匿名对象。a的存在是延长这个临时对象的生命周期。

### 实现移动语义
**移动语义**和**拷贝语义**相对的，移动语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁。

要实现移动语义，需要定义移动构造函数，还可以定义移动赋值操作符。对于右值的拷贝和赋值会调用移动构造函数和移动赋值操作符。

 在转移资源后，被移动的对象处于“有效但未定义的状态”（valid but unspecified state）

```cpp
struct Foo {
   Foo() { std::cout << "Constructed" << std::endl; }
   Foo(const Foo &) { std::cout << "Copy-constructed" << std::endl; }
   Foo(Foo &&) { std::cout << "Move-constructed" << std::endl; }
   ~Foo() {}
};

int main()
{
    Foo f1;                       // 默认构造函数
    Foo f2 = f1;                  // 拷贝构造函数
    Foo f3 = std::move(f1);       // 移动构造函数：将左值f1强制转换为将亡值，调用移动构造函数构造一个新对象。这里发生了资源所有权的转移。
    Foo&& f4 = std::move(f3);     // 不调用构造函数：声明并初始化一个引用，而不是创建一个新对象，没有发生任何资源转移，只是延长了这个将亡值的生命周期。
}
```
output:
```
Constructed
Copy-constructed
Move-constructed
```
### 实现完美转发

## 引用绑定规则
