---
layout: post
title: C++面向对象：类
slug: cpp-constructor
categories: [C++总结]
tags: [C++面向对象]
---

## 类的定义
见[C++关键字-struct和class](https://nowhere-man.github.io/2025/01/07/struct-and-class/)

## 类的构造函数和析构函数
见[构造函数和析构函数](https://nowhere-man.github.io/2025/04/01/cpp-constructor/)

## 类的拷贝控制
见[]()

## 友元
见[]()

## 类的核心特性之封装
见[]()

## 类的核心特性之继承
见[]()
见[]()

## 类的核心特性之多态
见[]()


## this指针
编译器会给每个**非静态**的**成员函数**增加了一个隐藏的常量指针：`T * const this`。

this指针指向当前对象，并且不能改变this指针的指向。

this指针本质上是非静态成员函数一个的形参：是对象调用成员函数时，将对象地址作为实参传递给函数，所以对象中不存储this指针。

this指针本身并不作为对象的一部分存储在对象的内存布局中。它是在函数被调用时，通过参数传递机制在栈上创建的。

const成员函数实际上限制的是this，将`T * const this`限定成`T const * const this`。

## 类成员函数的内联
只要在类声明的**内部**定义并**实现**了成员函数，编译器就会自动将其视为内联函数。

如果在类定义外部实现成员函数，同时希望它是内联的，那么必须在函数定义时使用inline关键字。
```cpp
class Foo {
public:
    void bar(); // 声明不需要加inline关键字
};

// 在类外定义时才加inline关键字
inline void Foo::bar() {}
```

## 类的静态成员
类的静态成员不属于类的任何一个具体对象，而是属于整个类本身。所有该类的对象都共享同一个静态成员。

静态成员函数不与任何特定对象绑定，因此没有this指针

其他用法见[C++关键字-static](https://nowhere-man.github.io/2025/01/02/static/)


## 类的嵌套

 在一个类的内部声明另一个类，我们称外面的类为封闭类，Enclosing Clas；内部的类为嵌套类，Nested Class。

嵌套类必须在类的内部声明，但是可以定义在类的内部或者外部。

类中声明并定义
```cpp
class Outer {
public:
    class Inner {
    public:
        void InnerFunc() {}
    };

    void OuterFunc() {}
};
```
类中声明，类外定义
```cpp
class Outer {
public:
    class Inner;
    void OuterFunc() {}
};

class Outer::Inner {
public:
    void InnerFunc();
};

void Outer::Inner::InnerFunc() {}
```
作用域：
+ 在封闭类内部，可以直接使用嵌套类的名字来创建对象。
+ 在封闭类外部，你需要使用作用域解析符`::`来引用嵌套类。

嵌套类对封闭类成员的访问
+ 嵌套类不能直接访问封闭类的非静态成员。因为嵌套类没有封闭类对象的this指针。
+ 嵌套类可以访问封闭类的静态成员。

封闭类对嵌套类成员的访问：遵循封闭类成员的访问修饰符。

类外部对嵌套类成员的访问：遵循封闭类的访问修饰符。

```cpp
class Outer {
public:
    class Inner {
    public:
        int a;
        static int b;
    private:
        int c;
        static int d;

        void InnerFunc() {
            a = 1;
            b = 1;

            Outer::a = 1; // 编译报错
            Outer::b = 2; // ok

            Outer::c = 3; // 编译报错
            Outer::d = 4; // ok
        }
    };

    int a;
    static int b;

    void OuterFunc() {
        Inner i;
        i.a = 1;
        i.b = 2;

        i.c = 3; // 编译报错
        i.d = 4; // 编译报错
    }
private:
    int c;
    static int d;
};
```
