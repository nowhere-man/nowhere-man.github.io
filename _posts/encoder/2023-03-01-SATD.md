---
layout: post
title: 对SATD理解
slug: satd
categories: [视频开发]
tags: [H.264]
---

## 为什么SATD越大，画面内容越复杂？

### 1. **SATD的计算过程**
- SATD 是将当前块与预测块的像素差值，经过变换（如Hadamard变换）后，取绝对值再求和。
- 公式简化为：
  $
  \text{SATD} = \sum_{i} |T(\text{原始块} - \text{预测块})_i|
  $
   , 其中$T$表示变换操作。

---

### 2. **物理意义**
- **预测块**：编码器会用运动估计、帧间/帧内预测等方法，预测当前块的内容。
- **残差**：原始块与预测块的差异，称为残差。
- **变换**：如Hadamard或DCT，将残差从空间域变换到频域，便于能量聚集和后续量化。

---

### 3. **SATD与内容复杂度的关系**
- **内容简单时**：预测块和原始块很接近，残差很小，变换后绝对值和（SATD）也很小。
- **内容复杂时**：预测块难以准确还原原始块，残差大，变换后SATD也大。
- **高频信息多**（如纹理、噪声、运动剧烈）：预测难度大，SATD大。
- **低频/平坦区域**（如大面积纯色、静止）：预测容易，SATD小。

---

### 4. **直观理解**
- SATD 本质上是“预测失败的总量”，即编码器没法用简单预测还原的那部分内容。
- 预测失败越多，说明内容越复杂，编码难度越大。

---

### 5. **举例**
- **静止蓝天**：预测块和原始块几乎一样，SATD接近0。
- **树叶、草地、运动物体**：预测块和原始块差异大，SATD很大。

---

### 6. **总结**
- **SATD越大，说明预测残差越大，内容越复杂。**
- **复杂内容需要更多比特编码，SATD是衡量复杂度的有效指标。**

## 为什么SATD越大，预测的比特数越多？
通过计算SATD（Sum of Absolute Transformed Differences，变换域绝对差和），可以**预测**每一帧的比特大小，但不是直接“得到”比特大小。其原理如下：

---

### 1. **SATD是什么？**
- SATD 是衡量一帧（或宏块、CU等）内容复杂度的指标，反映了该区域与预测值之间的残差能量。
- SATD 越大，说明内容越复杂，编码后残差越大，通常需要更多比特来表示。

---

### 2. **SATD与比特数的关系**
- 在视频编码中，**比特数 ≈ 复杂度 / 量化步长（QScale）**。
- 复杂度常用 SATD 或 SAD（绝对差和）来衡量。
- 量化步长越大，压缩越狠，比特数越少；复杂度越高，比特数越多。

---

### 3. **预测比特数的经验公式**
编码器通常会用如下经验公式来预测比特数：

$$
\text{bits} \approx \alpha \cdot \frac{\text{SATD}}{\text{QScale}}
$$

- 其中 \(\alpha\) 是通过统计回归等方法得到的经验参数。
- 这个公式的物理意义是：**在相同量化强度下，内容越复杂（SATD大），需要的比特越多**。

---

### 4. **实际代码实现**
在 x265 的 ABR 码控中，预测比特数的函数通常类似这样：

```cpp
double predictSize(Predictor *p, double q, double var)
{
    // p->coeff, p->count, p->offset 通过历史数据拟合
    return (p->coeff * var + p->offset) / q;
}
```
- 其中 `var` 就是 SATD，`q` 是 QScale。
- 预测出来的值就是当前帧在该 QScale 下大致会产生多少比特。

---

### 5. **为什么这样做有效？**
- 统计学上，SATD 与实际编码比特数有很强的相关性。
- 编码器会不断用历史帧的实际比特数和SATD来拟合/更新预测参数，使得预测越来越准确。

---

### 6. **总结**
- **SATD 反映了帧的复杂度，复杂度越高，编码后比特数越多。**
- **通过经验公式（SATD/QScale）可以较准确地预测每帧的比特数。**
- **实际比特数还会受到熵编码、运动补偿等影响，但SATD是最主要的复杂度指标之一。**