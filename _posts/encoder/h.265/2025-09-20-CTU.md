---
layout: post
title: H.265块划分
slug: h265-block-split
categories: [视频开发]
tags: [H.265]
date: 2025-09-20 00:00:00 +0800
---

## CTU

CTU是HEVC处理视频帧的基本单位，取代了H.264中的宏块（Macroblock）。

+   **作用**：作为一帧图像划分的起点和编码处理的入口。编码器会依次处理图像中的每一个CTU。
+   **大小**：在序列参数集（SPS）中指定，可以是16x16、32x32或64x64的亮度像素块。
+   **结构**：一个CTU包含一个亮度CTB和对应的两个色度CTB。它是一棵四叉树的根节点。

**CTU 尺寸是在 SPS 中定义的全局参数**，其作用域是整个视频序列或一个 GOP。

对于使用同一个 SPS 的所有帧，**CTU 尺寸是严格固定、不能改变的**。一帧内的所有 CTU 尺寸也完全相同。

在整个码流的生命周期中，可以通过**发送新的 SPS**来**改变后续帧的 CTU 尺寸**以及其他编码参数。这种改变通常发生在关键帧（IDR 帧）上。

## CU

CU 是从 CTU 通过**四叉树（Quadtree）**结构划分而来的。它是进行预测和变换模式决策的核心单元。

+   **作用**：决定使用何种预测方式（帧内/帧间）和变换方式。编码器会根据率失真优化（RDO）原则来决定一个 CU 是否需要继续分裂。
+   **划分**：一个大的 CU (例如 64x64) 可以被划分为 4 个更小的 CU (4个 32x32)。这个过程可以递归进行，直到达到最小 CU 尺寸（如 8x8）。
    +   如果一个 CU 不再分裂，它就成为一个**叶子节点（Leaf CU）**。
    +   图像内容平坦的区域倾向于使用大的 CU，而细节和纹理丰富的区域则倾向于分裂成小的 CU。
+   **尺寸**：从 64x64 到 8x8。
+   **关键点**：**CU 是承载 PU 和 TU 的容器**。一旦 CU 的划分确定，就在这个叶子 CU 的基础上进行 PU 和 TU 的划分。

## PU

PU 定义了在一个 CU 内部，如何进行**预测操作**。每个叶子 CU 都会根据其预测模式被划分为一个或多个 PU。

+   **作用**：PU 是**预测信息**（如帧内预测模式、帧间预测的运动矢量MV和参考帧索引）的基本单位。同一个 CU 内的所有 PU 共享相同的预测类型（Intra 或 Inter）。
+   **划分**：PU 的划分方式非常灵活，这对于精确描述运动特别重要。
    +   **帧内预测 (Intra Prediction)**：PU 划分通常比较简单，主要是 `2Nx2N` 和 `NxN`（仅当CU为最小尺寸时）。
    +   **帧间预测 (Inter Prediction)**：PU 划分方式非常丰富，包括对称和非对称的划分：
        +   `2Nx2N`：整个 CU 作为一个 PU。
        +   `2NxN`, `Nx2N`：对称划分。
        +   `NxN`：对称划分（仅当CU为2Nx2N时）。
        +   `2NxnU`, `2NxnD`：非对称划分（上下）。
        +   `nLx2N`, `nRx2N`：非对称划分（左右）。

>   PU 的划分**不影响** TU 的划分。它们是**基于同一个 CU 的两种不同维度的划分**。

## TU

TU 定义了在 CU 内部，如何对预测后的**残差数据**进行**变换和量化**。

+   **作用**：TU 是进行离散余弦变换（DCT）或离散正弦变换（DST）以及量化的基本单位。
+   **划分**：与 CU 类似，TU 也是基于**四叉树**结构进行划分的。这个 TU 四叉树的根节点就是 CU 本身。编码器可以决定不划分（TU 尺寸等于 CU 尺寸），或者递归地将一个大 TU 划分为 4 个小 TU。
+   **尺寸**：从 **32x32** 到 4x4。
+   **关键点**：TU 的四叉树划分嵌套在 CU 内部，且**独立于** PU 的划分。大尺寸的 TU 适合平坦区域的低频残差，而小尺寸的 TU 适合复杂区域的高频残差。

## CTU，CTB，CU，CB的关系

**Unit (单元)** 指的是一个处理和决策的**逻辑概念**，它包含了语法元素；

**Block (块)** 指的是与该单元对应的**实际像素数据**。

+   **CTU (编码树单元)**：
    +   这是一个**逻辑概念**。它是编码和解码过程中的一个基本处理单元。
    +   它是一个容器，包含了与这块图像区域相关的所有**语法元素**和决策信息，例如 CU 的划分方式（分裂标志）、预测模式、运动矢量、量化后的系数等等。
    +   CTU 是 CU 四叉树的**根节点**。
+   **CTB：
    +   这是一个**数据概念**。它指的是 CTU 所对应的**实际像素块**。
    +   一个 CTB 包含一个亮度（Luma）CTB 和两个色度（Chroma）CTB（在 4:2:0 采样格式下）。例如，一个 64x64 的 CTU 对应一个 64x64 的亮度 CTB 和两个 32x32 的色度 CTB。
    +   你可以把它想象成是上述 `class` 实例中指向一块内存的指针，这块内存里存着 `uint8_t` 类型的像素值。
    +   **关系**：解码器处理一个 **CTU**，是为了正确地重建它所对应的 **CTB** 像素数据。

**简单来说：CTU 是对 CTB 进行处理的指令集和容器。**

***

CB 是一个更通用的概念。

+   **CU (编码单元)**：是一个逻辑单元，是通过 CTU 四叉树划分得到的。
+   **CB (编码块)**：与 CU 对应的**实际像素数据块**就是CB。

所以，CTU 和 CTB 的关系，与 CU 和 CB 的关系是完全一样的。**CTB 其实是 CB 的一个特例**，当一个 CU 的尺寸等于 CTU 的尺寸时（也就是在四叉树的根节点上），它对应的 CB 就被称为 CTB。

**关系链**：

+   一个 CTU 对应一个 CTB。
+   这个 CTU可以分裂成 4 个子 CU。
+   这 4 个子CU 每一个都对应一个自己的 CB。
+   这 4 个 CB 在空间上组合起来，就构成了父节点 CU 对应的那个 CB (也就是 CTB)。

***

PU、PB与TU、TB也是类似：

+   **PU (Prediction Unit)**：预测单元，是进行预测操作的逻辑单元，包含运动矢量、参考帧索引等**语法信息**。

+   **PB (Prediction Block)**：预测块，是 PU 对应的**像素数据块**。解码器根据 PU 中的信息，从参考帧中取出预测块 PB，或者通过邻近像素生成预测块 PB。

+   **TU (Transform Unit)**：变换单元，是进行变换和量化的逻辑单元，包含量化后的变换系数等**语法信息**。

+   **TB (Transform Block)**：变换块，是 TU 对应的**残差数据块**。解码器对 TB 进行反量化和反变换，得到重建的残差。

## CTU，CU，PU，TU的关系

**核心关系**：

1.  一帧图像被划分为多个 **CTU**。
1.  每个 CTU 作为一个根节点，通过四叉树分裂成一个 **CU** 的层级结构。
1.  树的叶子节点，即不再分裂的 **CU**，是进行具体编码决策的单元。
1.  在每个叶子 CU 内部，会进行两种**独立的**划分：
    +   划分为一个或多个 **PU**，用于进行预测。
    +   划分为一个或多个 **TU**（通过另一个四叉树），用于对残差进行变换。

一个 64x64 的 CTU 开始的划分过程：

```
+---------------------------------------------------------------+
| CTU (64x64)                                                   |
|  = Root CU (64x64)                                            |
|                                                               |
|  +---------------------------+---------------------------+    |
|  | CU_0 (32x32)              | CU_1 (32x32)              |    |
|  | (Leaf CU, 不再分裂)        |                           |    |
|  |                           |                           |    |
|  +---------------------------+---------------------------+    |
|  | CU_2 (32x32)              | CU_3 (32x32) -> SPLIT     |    |
|  |                           | +-----------+-----------+ |    |
|  |                           | |CU_3_0(16) |CU_3_1(16) | |    |
|  |                           | +-----------+-----------+ |    |
|  |                           | |CU_3_2(16) |CU_3_3(16) | |    |
|  |                           | +-----------+-----------+ |    |
|  +---------------------------+---------------------------+    |
+---------------------------------------------------------------+
             |
             |
             V (我们放大看左上角的 CU_0 这个叶子节点)

+---------------------------+
| Leaf CU (32x32)           |
+---------------------------+
             |
             +--------------------------------------+
             | (Prediction Partitioning)            | (Transform Partitioning)
             V                                      V
+---------------------------+          +---------------------------+
| PU Partitioning           |          | TU Partitioning (Quadtree)  |
| (例如: Inter, 2NxN模式)     |          | (例如: 分裂一次)            |
|                           |          |                           |
| +-----------------------+ |          | +-----------+-----------+ |
| |      PU_A (32x16)     | |          | | TU (16x16)| TU (16x16)| |
| | (拥有自己的MV和ref_idx) | |          | +-----------+-----------+ |
| +-----------------------+ |          | | TU (16x16)| TU (16x16)| |
| |      PU_B (32x16)     | |          | +-----------+-----------+ |
| | (拥有自己的MV和ref_idx) | |          |                           |
| +-----------------------+ |          |                           |
+---------------------------+          +---------------------------+
```