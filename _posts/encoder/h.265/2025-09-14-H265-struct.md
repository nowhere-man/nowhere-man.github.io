---
layout: post
title: H.265混合编码框架
slug: h265-struct
categories: [视频开发]
tags: [H.265]
---

![](/assets/images/h265-struct.png)

### **1. 输入与分割**

+   **输入视频信号**: 原始的、未经压缩的视频帧序列作为编码器的输入。
+   **分割为CTU**: 每一帧图像首先被分割成一个个**编码树单元 (Coding Tree Unit, CTU)**。CTU是HEVC处理的基本单位，每个CTU还可以根据内容的复杂度，被递归地分割成更小的**编码单元 (Coding Unit, CU)**。

### **2. 核心编码循环**

编码的核心思想是**预测 (Prediction)**。我们不直接编码像素本身，而是先对它做一个预测，然后只编码原始像素与预测值之间的**残差 (Residual)**。因为残差的数值通常远小于原始像素值，所以更容易被压缩。

这个循环主要包含两个分支：**帧内预测 (Intra-Prediction)**和**帧间预测 (Inter-Prediction)**。

#### **2.1 帧内预测**

+   **帧内预测估计**: 这个过程用于处理视频的空间冗余（即同一帧内相邻像素的相似性）。它会分析**当前块周围已经编码完成的邻近像素**。
+   **帧内预测**: 基于邻近像素，使用多种预定义的角度模式（例如水平、垂直、45度角等，HEVC支持多达**35种模式**）来生成当前块的预测。
+   **输出**: 帧内预测数据（Intra Prediction Data），主要是所选择的预测模式。

#### **2.2 帧间预测 **

+   **运动估计 (Motion Estimation)**: 这个过程用于处理视频的时间冗余（即连续帧之间的相似性）。编码器会在已经编码并解码完成的参考帧（存储在**解码图像缓冲区 (Decoded Picture Buffer)**中）里，为当前的图像块寻找一个最匹配的块。
+   **运动补偿 (Motion Compensation)**: 找到最佳匹配块后，系统会记录下两者之间的位移，这个位移就是**运动矢量 (Motion Vector, MV)**，同时还会记录所参考的帧。然后，编码器利用这个运动矢量和参考帧来生成当前块的预测块。
+   **输出**: 运动数据（Motion Data），包括运动矢量、参考帧索引等信息。

#### **2.3 模式选择**

编码器会同时尝试帧间和帧内两种预测方式，然后通过一个复杂的**率失真优化** (Rate-Distortion Optimization, RDO) 算法，来决定哪种预测方式更好。选择的标准是：在达到可接受的失真（质量）前提下，哪种方式产生的残差和附加信息（如运动矢量）所需的编码比特数最少。

### **3. 残差处理**

1.  **计算残差**: 将原始的CTU（或CU）减去上一步选择的最佳预测块，得到**残差块**。
1.  **变换 (Transform), 缩放 (Scaling) & 量化 (Quantization)**:
    +   **变换**: 对残差块进行块变换（离散余弦变换DCT），将其从空间域转换到频率域。这样做的目的是将信号的能量集中到少数几个低频系数上。
    +   **缩放与量化**: 这是视频编码中主要的**有损**步骤。编码器会对变换后的系数进行量化，即用一个较大的步长去除这些系数，然后取整。这个过程会丢弃大量人眼不敏感的高频信息，从而极大地减少了需要编码的数据量。量化步长越大，压缩率越高，但图像质量损失也越大。
    +   **输出**: 量化后的变换系数 (Quantized Transform Coefficients)。

### **4. 重建与环路滤波 **

为了让后续的帧能够基于当前帧进行准确的帧间预测，编码器内部必须**模拟解码器的行为**，重建一个和解码器端完全一样的图像。

1.  **反量化与反变换 (Scaling & Inverse Transform)**: 对量化后的系数进行反向量化（乘以量化步长）和反变换，将数据从频率域恢复到空间域，得到重建的残差。
1.  **重建图像**: 将重建的残差与之前生成的预测块相加，就得到了一个重建的图像块。
1.  **环路滤波 (In-loop Filters)**: 由于**块处理和量化会引入一些视觉上的瑕疵（如块效应和振铃效应）**，HEVC在编码环路内部使用了两种滤波器来提升图像质量：
    +   **去块效应滤波器 (Deblocking Filter)**: 平滑块与块之间的边界，减少马赛克感。
    +   **样点自适应偏移 (Sample Adaptive Offset, SAO)**: 对重建像素值进行分类，然后加上一个偏移量来**补偿原始信号与重建信号之间的整体偏差**，进一步减少失真。
1.  **存入缓冲区**: 经过滤波后的高质量重建帧会被存入**解码图像缓冲区 (Decoded Picture Buffer, DPB)**，作为后续帧进行运动估计和补偿的参考。

### **5. 熵编码 (Entropy Coding)**

这是编码的最后一步，是一个**无损**压缩过程。

+   **头部格式化 & CABAC (Header Formatting & CABAC)**: 将编码过程中产生的所有信息，包括：

    +   **量化后的变换系数**
    +   **帧内预测模式信息**
    +   **运动数据（运动矢量等）**
    +   **滤波器控制数据**
    +   以及其他控制数据（如CTU分割信息等）

    通过**上下文自适应二进制算术编码 (Context-Adaptive Binary Arithmetic Coding, CABAC)**进行高效的无损压缩。CABAC会根据上下文（即邻近的语法元素）动态调整概率模型，从而达到比固定概率模型更高的压缩率。

+   **输出**: 最终生成的**编码比特流 (Coded Bitstream)**。这个比特流就可以用于存储或网络传输了。