---
layout: post
title: H.264 变换和量化
slug: h264-t-q
categories: [视频开发]
tags: [H.264]
---

在视频编码中，我们通常处理的是**预测残差（Residual）**。所谓残差，就是原始图像块减去预测图像块后得到的数据。直接对残差数据进行编码效率很低，因为：

1. 残差数据在空间上仍然存在大量相关性。
1. 人眼对不同频率的噪声敏感度不同。直接编码无法利用这一点。

因此，变换和量化这两个步骤被引入，它们的目标是：

1. **变换 (Transform)**：将空间域（spatial domain）的残差数据，通过类似离散余弦变换（DCT）的数学运算，转换到频率域（frequency domain）。
   + **能量集中**：变换后，残差块的大部分能量（重要信息）会集中在左上角的少数几个低频系数上。右下角的大量高频系数通常会接近于零。
   + **去相关性**：消除残差像素之间的空间相关性，使得数据更适合压缩。
1. **量化 (Quantization)**：这是 H.264 中**主要的有损压缩步骤**。它对变换后的频率系数进行“粗化”处理。
   + **数据削减**：通过除以一个量化步长（Quantization Step）并取整，大幅减少需要表示的数据量。那些接近零的高频系数在量化后会直接变成零，这对于后续的熵编码（如 CABAC/CAVLC）极为有利。
   + **码率控制**：量化是控制视频码率和质量的核心工具。量化越粗糙（步长越大），压缩率越高，但图像质量损失也越大。

**流程图 (ASCII Art):**

```
                  +-----------------+      +-----------------+      +-----------------+
Original Block -> |   Prediction    | ->   |   Residual      | ->   |   Transform     |
                  +-----------------+      | (Spatial Domain)|      | (To Frequency)  |
                                           +-----------------+      +-----------------+
                                                                            |
                                                                            v
                  +-----------------+      +-----------------+      +-----------------+
Entropy Coding -> | Quantized Coeffs| <-   |  Quantization   | <-   | Freq. Coefficients|
(e.g., CABAC)     | (Many are zero) |      | (Lossy Step)    |      | (Energy Compacted)|
                  +-----------------+      +-----------------+      +-----------------+
```



### 2. H.264 中的整数变换



早期的视频标准（如 MPEG-2）使用浮点数的离散余弦变换（DCT）。但这会导致编码器和解码器之间因浮点数精度问题产生**“失配”（mismatch）**，从而造成图像错误累积。

H.264 的一个重大创新是采用了**整数变换**，它完全避免了浮点运算，保证了编码器和解码器之间可以精确匹配。

#### 2.1 核心变换：4x4 整数变换

这是 H.264中最常用、最基础的变换，应用于亮度和色度残差的 4x4 块。

假设我们有一个 4x4 的残差块 X：

$$X = \begin{bmatrix} x_{00} & x_{01} & x_{02} & x_{03} \\ x_{10} & x_{11} & x_{12} & x_{13} \\ x_{20} & x_{21} & x_{22} & x_{23} \\ x_{30} & x_{31} & x_{32} & x_{33} \end{bmatrix} $$

变换后的系数块 $Y$ 通过以下公式计算：$$Y = C \cdot X \cdot C^T$$其中 $C$ 是变换矩阵，$C^T$ 是它的转置。H.264 定义的变换矩阵 $C$ 是：

$$ C = \begin{bmatrix} 1 & 1 & 1 & 1 \\ 2 & 1 & -1 & -2 \\ 1 & -1 & -1 & 1 \\ 1 & -2 & 2 & -1 \end{bmatrix} $$

**关键点**： - 这是一个二维变换，等效于先对 $X$ 的每一行进行一维变换（乘以 $C^T$），然后对结果的每一列进行一维变换（乘以 $C$）。

- 矩阵中只有整数 1 和 2，在硬件或软件实现中可以完全用加法和位移（shift）运算来代替乘法，效率极高。
- 变换后的左上角系数 $y\_{00}$ 称为 **DC 系数（直流分量）**，它代表了该 4x4 块的平均能量。其他 15 个系数称为 **AC 系数（交流分量）**，代表不同频率的细节。

#### 2.2 Hadamard 变换

在进行了 4x4 变换后，每个 4x4 块都会产生一个 DC 系数。对于一个 16x16 的亮度宏块，就会有 16 个 DC 系数。这些 DC 系数之间仍然存在相关性。因此，H.264 会将这 16 个 DC 系数组织成一个 4x4 的块，并对其进行一次额外的 **Hadamard 变换**。 $$Y_{DC} = H \cdot D \cdot H^T$$ 其中 $D$ 是由 16 个 DC 系数组成的 4x4 块， $H$ 是 Hadamard 变换矩阵：
$$H = \begin{bmatrix} 1 & 1 & 1 & 1 \\ 1 & 1 & -1 & -1 \\ 1 & -1 & -1 & 1 \\ 1 & -1 & 1 & -1 \end{bmatrix} $$
同样，这个变换也只包含 `+1` 和 `-1`，计算非常高效。色度块（Chroma）的 DC 系数也会进行一个 2x2 的 Hadamard 变换。

#### 2.3 8x8 整数变换

为了更好地处理高清（HD）视频中的平坦区域，H.264 的 High Profile 引入了 8x8 的整数变换。其原理与 4x4 变换类似，但使用了更大的变换块和更复杂的 8x8 变换矩阵，能更有效地集中大块平坦区域的能量。

### 3\. 量化 (Quantization)

量化过程在数学上看起来很简单，但其背后的控制逻辑非常复杂。

#### 3.1 前向量化 (Forward Quantization)
编码器端 对于变换后的一个系数 $Y\_{ij}$，其量化后的系数 $Z\_{ij}$ 计算公式如下：

 $$Z_{ij} = \text{round} \left( \frac{Y_{ij}}{Q_{step}} \right)$$

这里的 $Q\_{step}$ 是**量化步长**。

然而在 H.264 中，事情要稍微复杂一些。标准没有直接定义 $Q\_{step}$，而是引入了一个**量化参数 (Quantization Parameter, QP)**。

**QP**: 一个从 0 到 51 的整数。QP 越小，量化越精细，质量越高，码率也越高。QP 越大，量化越粗糙，质量越低，码率也越低。

**QP 与 $Q\_{step}$ 的关系**: QP 每增加 6，量化步长 $Q\_{step}$ 就**翻倍**。这是一种对数量化策略，符合人眼的视觉感知特性。 完整的量化公式（简化版）为：
$$Z_{ij} = \text{sign}(W_{ij}) \cdot \left( \lfloor \frac{|W_{ij}| \cdot MF}{2^{15+q_{bits}}} + f \rfloor \right)$$
让我们把它简化成一个更容易理解的形式：

 $$Z_{ij} = \text{round} \left( \frac{W_{ij} \cdot \text{ScalingFactor}}{Q_{step}} \right)$$

这里的 $W\_{ij}$ 是变换后的系数。公式中的 $MF$ 和 $q\_{bits}$ 等参数实际上是把变换和量化过程中的缩放因子（Scaling Factor）合并到了一起，以避免多次乘除法，提高计算效率。

#### 3.2 逆量化/反量化 (Inverse Quantization)
解码器端 解码器接收到量化后的系数 $Z\_{ij}$，需要将其恢复。这个过程称为逆量化。 $$Y'_{ij} = Z_{ij} \cdot Q_{step} \cdot \text{ScalingFactor}'$$ 注意，这里的 $Y'*{ij}$ 已经不是原始的变换系数 $Y*{ij}$ 了，因为量化过程中的取整操作导致了信息丢失。**这就是有损压缩的根源**。 $$Y'_{ij} \approx Y_{ij}$$ 解码器就用这个近似恢复的系数 $Y'\_{ij}$ 进行反变换，得到重建的残差块。

#### 3.3 频率加权量化 (Frequency-based Quantization Scaling)
H.264 还支持使用**缩放矩阵 (Scaling Matrix)** 来进行更精细的量化控制。编码器可以定义 4x4 或 8x8 的矩阵，让不同频率位置的系数使用不同的量化权重。 $$Z_{ij} = \text{round} \left( \frac{W_{ij} \cdot \text{ScalingFactor}}{Q_{step} \cdot \text{ScalingMatrix}_{ij}} \right)$$ 这利用了人眼对高频噪声不敏感的特性。通过为高频位置的系数（矩阵右下角）设置更大的缩放值，可以对它们进行更粗糙的量化，从而在主观质量几乎不变的情况下节省码率。

### 4\. 其他
1.  **整数运算与位移**：H.264 的变换和量化被精心设计为只使用整数运算。在 C++ 实现中，乘法和除法都可以用位移（`<<`, `>>`）和加减法来完成。这对于性能至关重要，尤其是在没有 FPU 的嵌入式平台上。     ```cpp    // Example: A simplified 1D forward 4x4 transform step    // Y = C * X    // y0 = x0 + x1 + x2 + x3;    // y1 = 2*x0 + x1 - x2 - 2*x3;  // 2*x0 can be (x0 << 1)    // ...    ```
2.  **查表法 (Lookup Tables)**：量化和逆量化中的 $Q\_{step}$ 和缩放因子通常是根据 QP 预先计算好并存储在查找表（LUT）中的。在代码中，你会看到类似 `QStep[QP % 6]` 和 `ScalingFactor[QP]` 这样的实现，用空间换时间。
3.  **数据流与内存布局**：理解数据如何从一个 16x16 的残差块被分解成 16 个 4x4 的小块，然后进行变换、扫描（Zig-zag scan）、量化，对于编写高效的内存访问代码很有帮助。缓存友好（Cache-friendly）的数据布局可以显著提升性能。
4.  **码率控制算法**：QP 不是固定的，它由编码器的码率控制模块动态调整。如果你在开发编码器，你需要设计一个算法，根据目标码率、缓冲区占用情况和视频内容的复杂度来为每个宏块选择一个合适的 QP。这是一个充满挑战和权衡的领域。

### 总结
变换与量化是 H.264 编码流程的心脏，它们协同工作，将预测后的残差数据高效地压缩成适合传输和存储的码流。
- **变换**：通过整数 DCT 将空间域残差变为频率域系数，实现能量集中。
- **量化**：通过基于 QP 的除法和取整，粗暴但有效地丢弃次要信息（主要是高频细节），是压缩率和质量的“调节阀”。 理解了这两个过程，你就掌握了 H.264 有损压缩的本质。$$