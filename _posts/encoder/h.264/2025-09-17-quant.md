---
layout: post
title: H.264 变换和量化
slug: h264-t-q
categories: [视频开发]
tags: [H.264]
---

### 3\. 量化 (Quantization)

量化过程在数学上看起来很简单，但其背后的控制逻辑非常复杂。

#### 3.1 前向量化 (Forward Quantization)
编码器端 对于变换后的一个系数 $Y\_{ij}$，其量化后的系数 $Z\_{ij}$ 计算公式如下：

 $$Z_{ij} = \text{round} \left( \frac{Y_{ij}}{Q_{step}} \right)$$

这里的 $Q\_{step}$ 是**量化步长**。

然而在 H.264 中，事情要稍微复杂一些。标准没有直接定义 $Q\_{step}$，而是引入了一个**量化参数 (Quantization Parameter, QP)**。

**QP**: 一个从 0 到 51 的整数。QP 越小，量化越精细，质量越高，码率也越高。QP 越大，量化越粗糙，质量越低，码率也越低。

**QP 与 $Q\_{step}$ 的关系**: QP 每增加 6，量化步长 $Q\_{step}$ 就**翻倍**。这是一种对数量化策略，符合人眼的视觉感知特性。 完整的量化公式（简化版）为：
$$Z_{ij} = \text{sign}(W_{ij}) \cdot \left( \lfloor \frac{|W_{ij}| \cdot MF}{2^{15+q_{bits}}} + f \rfloor \right)$$
让我们把它简化成一个更容易理解的形式：

 $$Z_{ij} = \text{round} \left( \frac{W_{ij} \cdot \text{ScalingFactor}}{Q_{step}} \right)$$

这里的 $W\_{ij}$ 是变换后的系数。公式中的 $MF$ 和 $q\_{bits}$ 等参数实际上是把变换和量化过程中的缩放因子（Scaling Factor）合并到了一起，以避免多次乘除法，提高计算效率。

#### 3.2 逆量化/反量化 (Inverse Quantization)
解码器端 解码器接收到量化后的系数 $Z\_{ij}$，需要将其恢复。这个过程称为逆量化。 $$Y'_{ij} = Z_{ij} \cdot Q_{step} \cdot \text{ScalingFactor}'$$ 注意，这里的 $Y'*{ij}$ 已经不是原始的变换系数 $Y*{ij}$ 了，因为量化过程中的取整操作导致了信息丢失。**这就是有损压缩的根源**。 $$Y'_{ij} \approx Y_{ij}$$ 解码器就用这个近似恢复的系数 $Y'\_{ij}$ 进行反变换，得到重建的残差块。

#### 3.3 频率加权量化 (Frequency-based Quantization Scaling)
H.264 还支持使用**缩放矩阵 (Scaling Matrix)** 来进行更精细的量化控制。编码器可以定义 4x4 或 8x8 的矩阵，让不同频率位置的系数使用不同的量化权重。 $$Z_{ij} = \text{round} \left( \frac{W_{ij} \cdot \text{ScalingFactor}}{Q_{step} \cdot \text{ScalingMatrix}_{ij}} \right)$$ 这利用了人眼对高频噪声不敏感的特性。通过为高频位置的系数（矩阵右下角）设置更大的缩放值，可以对它们进行更粗糙的量化，从而在主观质量几乎不变的情况下节省码率。

### 4\. 其他
1.  **整数运算与位移**：H.264 的变换和量化被精心设计为只使用整数运算。在 C++ 实现中，乘法和除法都可以用位移（`<<`, `>>`）和加减法来完成。这对于性能至关重要，尤其是在没有 FPU 的嵌入式平台上。     ```cpp    // Example: A simplified 1D forward 4x4 transform step    // Y = C * X    // y0 = x0 + x1 + x2 + x3;    // y1 = 2*x0 + x1 - x2 - 2*x3;  // 2*x0 can be (x0 << 1)    // ...    ```
2.  **查表法 (Lookup Tables)**：量化和逆量化中的 $Q\_{step}$ 和缩放因子通常是根据 QP 预先计算好并存储在查找表（LUT）中的。在代码中，你会看到类似 `QStep[QP % 6]` 和 `ScalingFactor[QP]` 这样的实现，用空间换时间。
3.  **数据流与内存布局**：理解数据如何从一个 16x16 的残差块被分解成 16 个 4x4 的小块，然后进行变换、扫描（Zig-zag scan）、量化，对于编写高效的内存访问代码很有帮助。缓存友好（Cache-friendly）的数据布局可以显著提升性能。
4.  **码率控制算法**：QP 不是固定的，它由编码器的码率控制模块动态调整。如果你在开发编码器，你需要设计一个算法，根据目标码率、缓冲区占用情况和视频内容的复杂度来为每个宏块选择一个合适的 QP。这是一个充满挑战和权衡的领域。

### 总结
变换与量化是 H.264 编码流程的心脏，它们协同工作，将预测后的残差数据高效地压缩成适合传输和存储的码流。
- **变换**：通过整数 DCT 将空间域残差变为频率域系数，实现能量集中。
- **量化**：通过基于 QP 的除法和取整，粗暴但有效地丢弃次要信息（主要是高频细节），是压缩率和质量的“调节阀”。 理解了这两个过程，你就掌握了 H.264 有损压缩的本质。$$