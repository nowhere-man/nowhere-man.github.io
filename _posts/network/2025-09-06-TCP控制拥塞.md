---
layout: post
title: TCP协议：拥塞控制
slug: tcp-cc
categories: [网络编程]
tags: [TCP]
---

## 产生原因
网络中数据传输需要超过了网络能够处理的最大容量：
+ 数据管道容量
+ 网络设备缓冲区

产生控制拥塞后，数据包累积导致延迟，超过缓冲限制则大量丢失，影响传输效率和吞吐。

## 算法分类

| **拥塞控制大类**  | **具体算法**   | **特点**                                |
| ----------------- | -------------- | --------------------------------------- |
| **基于丢包**      | TCP Tahoe      | 慢启动、拥塞避免、                      |
|                   | **TCP Reno**   | 在Tahoe的基础上引入快速重传和快速恢复   |
|                   | TCP NewReno    |                                         |
|                   | TCP BIC        | 通过二分搜索算法快速找到cwnd            |
|                   | TCP CUBIC      | BIC的优化版本，使用三次函数平滑增长cwnd |
| **基于延迟**      | TCP Vegas      |                                         |
|                   | Fast TCP       |                                         |
|                   | LEDBAT         |                                         |
|                   | Copa           |                                         |
| **基于丢包+延迟** | TCP Nice       |                                         |
|                   | **WebRTC GCC** |                                         |
| **基于建模**      | TCP Westwood   |                                         |
|                   | **BBR/BBRv2**  |                                         |
| **基于学习**      | PCC            |                                         |
|                   | Gemini         |                                         |

## 算法评价指标
+ 吞吐量：在单位时间内成功传输的数据量。
+ 带宽利用率：吞吐量与网络最大可能吞吐量（即带宽）的比值
+ 时延：数据从发送端到接收端所需的时间。
+ 抖动：数据包在网络中传输时延的变化量。
+ 丢包率：在传输过程中丢失的数据包占总发送数据包的比例。
+ 收敛速度：网络条件发生变化时，调整其发送速率以达到稳定状态所需的时间。
+ 公平性：当多个连接共享同一网络链路时，算法如何分配带宽。

## 基于丢包

### TCP Tahoe
Tahoe算法主要包含三个核心机制：
1. 慢启动。
    1. 初始的cwnd为1个MSS。
    1. 每当发送方收到一个ACK，cwnd就会增加一个MSS。因此每经过一个RTT，cwnd会翻倍(指数增长)
    1. 慢启动会一直持续，直到cwnd达到一个预设的慢启动阈值ssthresh。
1. 拥塞避免。
    1. 当cwnd超过ssthresh后，从慢启动切换到拥塞避免阶段。
    1. 每经过一个RTT，cwnd就会增加一个MSS。
    1. 拥塞避免阶段会一直持续，直到发生丢包。
1. 快速重传：当发送方连续收到三个重复的ACK时，会认为发生丢包。发送方立即重传丢失的报文段，不必等待超时。并且当**发生丢包**或者**重传超时**，则：
    1. 将ssthresh设置为当前cwnd的一半。
    1. 将cwnd重置为1个MSS。重新进入慢启动阶段。

![](/assets/images/tcp-cc-tahoe.png)

***

算法缺陷：
+ 在发生丢包时，将cwnd重置为1，会导致连接吞吐量大幅下降。尤其是在高带宽、高延迟的网络环境中会严重影响性能。
+ 将所有丢包事件都视为严重的网络拥塞，实际并非如此。


### TCP Reno
Reno算法相比Tahoe多了一个快速恢复：
1. 慢启动。
1. 拥塞避免。
1. 快速重传：快速重传：当发送方连续收到三个重复的ACK时，会认为发生丢包。发送方立即重传丢失的报文段，不必等待超时。
1. 快速恢复。
    + 当**发生重传超时**：
        1. 将ssthresh设置为当前cwnd的一半，
        1. 将cwnd重置为1个MSS。重新进入慢启动阶段。
    + 当**发生丢包**：
        1. 将ssthresh设置为当前cwnd的一半。
        1. 将cwnd设置为新的ssthresh加上3个MSS，进入快速恢复阶段。
        1. 每收到一个重复ACK（和前三个重复ACK相同的ACK），cwnd增加1个MSS，直到收到一个对**新数据的ACK**。
        1. 退出快速恢复，进入拥塞避免状态。

> 每收到一个重复ACK，cwnd增加1个MSS：表示网络中又有一个数据包离开了，可以再发送一个数据。当收到一个新数据的ACK时，意味着先前丢失的报文段已经被成功确认，快速恢复阶段正式结束。

![](/assets/images/tcp-cc-reno.png)

***

算法缺陷：
+ Reno只为单次丢包设计，在面对一个RTT内发生多个丢包时表现不佳。
    1. 假设发送方发出了10个数据包：1-10。
    1. 接收方收到了1、2、3、4、6、7、9、10。
    1. 当收到6，7，9时，会发送3个重复的请求序号5的ACK。
    1. 发送方立即重传5，并触发快速恢复，但是并不知道8也丢失了。
    1. 接收方收到5后，发送一个请求序号8的ACK。
    1. 发送方收到这个请求序号8的ACK后，退出快速恢复阶段，重新进入拥塞避免。
    1. 由于8已经发生丢包，最终会导致重传超时，cwnd直接降到1，重新进入慢启动阶段。
+ 可能会将乱序到达的数据包误认为是丢包，导致错误地触发拥塞控制，降低传输速率。
+ AIMD机制(减少快，增长慢)导致在大窗口场景下，一个数据报的丢失所带来的窗口缩小要花费很长的时间才能恢复。

### TCP NewReno
NewReno解决了Reno在一个RTT内发生多个丢包时效率低下的问题。使得在快速恢复期间可以处理多个丢包，而无需等待超时。
+ Reno快速恢复算法中当发送方收到一个新的ACK就退出快速恢复状态。
+ New Reno算法中只有当**快速恢复期间所有已经发送但尚未被确认**的报文都被应答后才退出快速恢复状态。

这里引入两个概念：
+ 部分应答（Partial ACK/PACK）：如果收到的新ACK不是对已发送的**最大序列号**的确认，就称为PACK。PACK确认了在它之前丢失的包，但不确认后面那些在进入快速恢复之前发送的所有数据包。
+ 恢复应答（Recovery ACK/RACK）：如果收到的新ACK正好是已发送的最大序列号的确认，就称为RACK。发送方认为所有丢失的包都已被确认，拥塞结束，然后退出快速恢复状态。

NewReno算法改进了Reno算法中的快速恢复阶段：
+ 当**发生丢包**：
    1. 将ssthresh设置为当前cwnd的一半。
    1. 将cwnd设置为新的ssthresh加上3个MSS，进入快速恢复阶段。
    1. 每收到一个重复ACK，cwnd增加1个MSS。
    1. **当收到新的ACK，如果是PACK，会并立即重传序号为ACK的数据包，而不需要等待超时。**
    1. **直到收到的新的ACK为RACK，退出快速恢复，进入拥塞避免阶段。**

***

NewReno举例:
1. 假设发送方发出了10个数据包：1-10。
1. 接收方收到了1、2、3、4、6、7、9、10。
1. 当收到6，7，9时，会发送3个重复的请求序号5的ACK。
1. 发送方立即重传5，并触发快速恢复，但是并不知道8也丢失了。
1. 接收方收到5后，发送一个请求序号8的ACK。
1. 发送方收到这个请求序号8的ACK后，**不会退出快速恢复阶段**。
1. NewReno认为序号8的数据已丢失，它会立即重传数据包8。并持续停留在快速恢复状态。
1. 直到收到请求序号11的ACK，NewReno知道**所有在进入快速恢复之前发送的数据都已得到确认**。
1. 退出快速恢复，进入拥塞避免阶段。

***

NewReno算法缺陷：
+ 依然依赖于重复 ACK。
+ 依然存在对乱序数据包的误判。


### TCP BIC
### TCP CUBIC


## 基于延迟
TODO

## 基于丢包+延迟

### GCC

## 基于建模

### BBR
## 参考
+ [万字详文：TCP 拥塞控制详解](https://zhuanlan.zhihu.com/p/144273871)
