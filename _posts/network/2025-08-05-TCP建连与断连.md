---
layout: post
title: TCP协议 - 2 建立连接和断开连接
slug: tcp-connection-and-disconnection
categories: [网络编程]
tags: [TCP]
---

## 博客
+ [TCP协议详解及实战解析](https://blog.csdn.net/mumubumaopao/article/details/107929767)

## Q&A
### [TCP建立连接时为什么需要三次握手，而不是两次握手？](https://blog.csdn.net/lengxiao1993/article/details/82771768)
+ 第二次握手：服务端发送ACK=x+1，表示是对客户端Seq的确认。
+ 第三次握手：客户端发送ACK=y+1，表示是对服务端Seq的确认。



### 为什么四次挥手不能像三次握手那样合并？
在三次握手中，服务端回复的 SYN+ACK 是一个合成包，因为它在接收到客户端 SYN 后，可以立即进行自己的 SYN 并发送 ACK。

而在四次挥手中，第二次的 ACK 和第三次的 FIN 通常不能合并。因为服务端收到客户端的 FIN 后，它可能还有数据没有发送完毕。它会先回复 ACK 来确认收到关闭请求，然后继续发送数据。直到数据全部发送完毕后，它才会发出自己的 FIN 包。

当然，在某些特殊情况下，如果服务端在收到客户端的 FIN 时，自己的数据也已经发送完毕，那么它可以将 ACK 和 FIN 合并在一起发送，这样就会变成三次挥手。但这只是一种特殊优化，标准的关闭流程依然是四次。



### 第四次挥手的必要性

#### 解决2MSL问题，防止“串线”

这是第四次`ACK`存在的最关键原因，也是为什么客户端在发送`ACK`后会进入一个特殊的**`TIME_WAIT`状态**，并等待**2MSL（报文最大生存时间）**。

`TIME_WAIT`状态是为了防止以下情况发生：

1. 假设客户端发送了第四次`ACK`，但`ACK`在网络中丢失了。
1. 客户端立即关闭连接，端口被释放。
1. 一个**新的连接**立即使用了同一个端口，并且新的`SYN`包在网络中传输。
1. 此时，**之前丢失的那个`ACK`包突然又到达了服务端**。服务端收到`ACK`，正常关闭。
1. 然而，**之前丢失的旧连接数据包（比如`FIN`包）\**也可能在网络中\**滞留很久**，然后突然到达客户端新连接的端口。

这会导致旧连接的残余数据包被新的连接错误地接收，造成数据混乱，也就是我们常说的“**串线**”。

`TIME_WAIT`状态正是为了解决这个问题：

+ 客户端发送第四次`ACK`后，进入`TIME_WAIT`状态，并持续**2个MSL**（通常是1-4分钟）。
+ 在这段时间内，该端口**不能被新的连接使用**。
+ **MSL（Maximum Segment Lifetime）\**是任何数据包在网络中的最大存活时间。等待2个MSL，可以确保网络中\**所有与该旧连接相关的数据包**（包括丢失的`ACK`和重传的`FIN`）都彻底消失了。
+ 2MSL之后，客户端才真正关闭连接，端口被释放。此时再建立新连接，就不会有旧数据包的干扰。

**因此，第四次`ACK`不仅是让服务端安心关闭的确认，它更重要的作用是引出`TIME_WAIT`状态，为连接的彻底关闭和后续端口的复用提供了一个安全期。**